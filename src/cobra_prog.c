/* original parser id follows */
/* yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93" */
/* (use YYMAJOR/YYMINOR for ifdefs dependent on parser version) */

#define YYBYACC 1
#define YYMAJOR 2
#define YYMINOR 0
#define YYPATCH 20220114

#define YYEMPTY        (-1)
#define yyclearin      (yychar = YYEMPTY)
#define yyerrok        (yyerrflag = 0)
#define YYRECOVERING() (yyerrflag != 0)
#define YYENOMEM       (-2)
#define YYEOF          0
#undef YYBTYACC
#define YYBTYACC 0
#define YYDEBUGSTR YYPREFIX "debug"

#ifndef yyparse
#define yyparse    xxparse
#endif /* yyparse */

#ifndef yylex
#define yylex      xxlex
#endif /* yylex */

#ifndef yyerror
#define yyerror    xxerror
#endif /* yyerror */

#ifndef yychar
#define yychar     xxchar
#endif /* yychar */

#ifndef yyval
#define yyval      xxval
#endif /* yyval */

#ifndef yylval
#define yylval     xxlval
#endif /* yylval */

#ifndef yydebug
#define yydebug    xxdebug
#endif /* yydebug */

#ifndef yynerrs
#define yynerrs    xxnerrs
#endif /* yynerrs */

#ifndef yyerrflag
#define yyerrflag  xxerrflag
#endif /* yyerrflag */

#ifndef yylhs
#define yylhs      xxlhs
#endif /* yylhs */

#ifndef yylen
#define yylen      xxlen
#endif /* yylen */

#ifndef yydefred
#define yydefred   xxdefred
#endif /* yydefred */

#ifndef yystos
#define yystos     xxstos
#endif /* yystos */

#ifndef yydgoto
#define yydgoto    xxdgoto
#endif /* yydgoto */

#ifndef yysindex
#define yysindex   xxsindex
#endif /* yysindex */

#ifndef yyrindex
#define yyrindex   xxrindex
#endif /* yyrindex */

#ifndef yygindex
#define yygindex   xxgindex
#endif /* yygindex */

#ifndef yytable
#define yytable    xxtable
#endif /* yytable */

#ifndef yycheck
#define yycheck    xxcheck
#endif /* yycheck */

#ifndef yyname
#define yyname     xxname
#endif /* yyname */

#ifndef yyrule
#define yyrule     xxrule
#endif /* yyrule */

#if YYBTYACC

#ifndef yycindex
#define yycindex   xxcindex
#endif /* yycindex */

#ifndef yyctable
#define yyctable   xxctable
#endif /* yyctable */

#endif /* YYBTYACC */

#define YYPREFIX "xx"

#define YYPURE 0

#line 8 "cobra_prog.y"
#include "cobra.h"
#include <regex.h>
#include "cobra_array.h"
#include "cobra_list.h"

/* parser for inline programs*/

#define YYSTYPE	Lexptr
#define YYDEBUG 1
#define yyparse xxparse
#define NONE	-9
#define ISVAR	-7

typedef struct	Block	Block;
typedef struct	Cstack	Cstack;	/* function call stack*/
typedef struct	Lexlst	Lexlst;
typedef struct	Var_nm	Var_nm;	/* variables: int, str, ptr*/
typedef struct	REX	REX;

struct Lexlst {
	Lextok	*t;
	Lextok	*dst;
	Lexlst	*nxt;
};

struct Block {
	int	btyp;	/* non-zero only for while-blocks*/
	Lextok *enter;
	Lextok *leave;
	Block  *nxt;
};

struct Cstack {
	const char *nm;
	Lextok	*formals;
	Lextok	*actuals;
	Lextok	*ra;	/* return address*/
	Cstack	*nxt;
};

struct REX {
	regex_t *rexpr;
	char	*s;
	REX	*nxt;
};

struct Var_nm {
	Renum	rtyp;
	ulong	h2;		/* name hash*/
	const char *nm;
		Prim	*pm;	/* PTR*/
		char	*s;	/* STR*/
		int	v;	/* VAL*/
	int	cdepth;		/* fct call depth where defined*/
	Var_nm	*nxt;
};

static char *nr_tbl[] = {
	"0", "1", "2", "3", "4",
	"5", "6", "7", "8", "9"
};

#ifndef MAX_STACK
  #define MAX_STACK	512	/* recursive fct calls*/
#endif

static REX	*re_lst;
static REX	*re_free;

static Block	**block;
static Block	**b_free;	/* freelist for block*/

static Cstack	**cstack;
static Cstack	**c_free;	/* freelist for cstack*/

static Var_nm	**v_names;
static Var_nm	**v_free;	/* freelist for v_names*/

static Function	 *functions;
static Prim	  none;
static Lextok	 *p_tree;
static Var_nm	 *lab_lst;
Separate	 *sep;		/* thread local copies of globals*/

int	*Cdepth;

static int	 nest;
static int	 p_lnr = 1;
static int	 p_seq = 1;
static int	 n_blocks;	/* used during parsing*/
static int	 a_cnt;		/* conservative cnt of nr of arrays*/
static int	 v_cnt;		/* conservative cnt of nr of vars*/
static int	*t_stop;

char	*derive_string(Prim **, Lextok *, const int, const char *);

static Block	*pop_context(int, int);
static Lextok	*mk_for(Lextok *, Lextok *, Lextok *, Lextok *);
static Lextok	*new_lex(int, Lextok *, Lextok *);
static Var_nm	*mk_var(const char *, const int, const int);
static Var_nm	*check_var(const char *, const int);

/* to reduce the number of cache-misses in multicore mode:*/
	#define DUP_TREES

#ifdef DUP_TREES
 static void	 clear_dup(void);
 static Lextok	*dup_tree(Lextok *);
#endif

static Lextok	*add_return(Lextok *);
static void	handle_global(Lextok *);
static void	add_fct(Lextok *);
static void	fixstr(Lextok *);
static void	mk_fsm(Lextok *, const int);
static void	mk_lab(Lextok *, Lextok *);
static void	push_context(Lextok *, Lextok *, int, int);
static void	tok2txt(Lextok *, FILE *);
       void	what_type(FILE *, Renum);
static void	yyerror(const char *);

void	eval_prog(Prim **, Lextok *, Rtype *, const int);

extern void	new_array(char *, int);	/* cobra_array.c*/
extern int	setexists(const char *s);
extern void	show_error(FILE *, int);
extern int	xxparse(void);
extern Prim	*cp_pset(char *, int);	/* cobra_te.c*/
static int	yylex(void);

extern int	stream;
extern int	stream_override;
#line 254 "cobra_prog.c"

#if ! defined(YYSTYPE) && ! defined(YYSTYPE_IS_DECLARED)
/* Default: YYSTYPE is the semantic value type. */
typedef int YYSTYPE;
# define YYSTYPE_IS_DECLARED 1
#endif

/* compatibility with bison */
#ifdef YYPARSE_PARAM
/* compatibility with FreeBSD */
# ifdef YYPARSE_PARAM_TYPE
#  define YYPARSE_DECL() yyparse(YYPARSE_PARAM_TYPE YYPARSE_PARAM)
# else
#  define YYPARSE_DECL() yyparse(void *YYPARSE_PARAM)
# endif
#else
# define YYPARSE_DECL() yyparse(void)
#endif

/* Parameters sent to lex. */
#ifdef YYLEX_PARAM
# define YYLEX_DECL() yylex(void *YYLEX_PARAM)
# define YYLEX yylex(YYLEX_PARAM)
#else
# define YYLEX_DECL() yylex(void)
# define YYLEX yylex()
#endif

/* Parameters sent to yyerror. */
#ifndef YYERROR_DECL
#define YYERROR_DECL() yyerror(const char *s)
#endif
#ifndef YYERROR_CALL
#define YYERROR_CALL(msg) yyerror(msg)
#endif

extern int YYPARSE_DECL();

#define NR 257
#define STRING 258
#define NAME 259
#define IF 260
#define IF2 261
#define ELSE 262
#define WHILE 263
#define FOR 264
#define IN 265
#define PRINT 266
#define ARG 267
#define SKIP 268
#define GOTO 269
#define BREAK 270
#define CONTINUE 271
#define STOP 272
#define NEXT_T 273
#define BEGIN 274
#define END 275
#define SIZE 276
#define RETRIEVE 277
#define FUNCTION 278
#define CALL 279
#define ROUND 280
#define BRACKET 281
#define CURLY 282
#define LEN 283
#define MARK 284
#define SEQ 285
#define LNR 286
#define RANGE 287
#define FNM 288
#define FCT 289
#define ITOSTR 290
#define BOUND 291
#define MBND_D 292
#define MBND_R 293
#define NXT 294
#define PRV 295
#define JMP 296
#define UNSET 297
#define RETURN 298
#define RE_MATCH 299
#define FIRST_T 300
#define LAST_T 301
#define TXT 302
#define TYP 303
#define NEWTOK 304
#define SUBSTR 305
#define SPLIT 306
#define STRLEN 307
#define STRCHR 308
#define STRRCHR 309
#define SET_RANGES 310
#define CPU 311
#define N_CORE 312
#define SUM 313
#define A_UNIFY 314
#define LOCK 315
#define UNLOCK 316
#define ASSERT 317
#define TERSE 318
#define TRUE 319
#define FALSE 320
#define VERBOSE 321
#define FCTS 322
#define MARKS 323
#define SAVE 324
#define RESTORE 325
#define RESET 326
#define SRC_LN 327
#define HASH 328
#define HASHARRAY 329
#define ADD_PATTERN 330
#define DEL_PATTERN 331
#define IS_PATTERN 332
#define CP_PSET 333
#define ADD_TOP 334
#define ADD_BOT 335
#define POP_TOP 336
#define POP_BOT 337
#define TOP 338
#define BOT 339
#define OBTAIN_EL 340
#define RELEASE_EL 341
#define UNLIST 342
#define LLENGTH 343
#define GLOBAL 344
#define DISAMBIGUATE 345
#define PART 346
#define DEF 347
#define PACKAGE 348
#define OR 349
#define AND 350
#define B_OR 351
#define B_AND 352
#define B_XOR 353
#define EQ 354
#define NE 355
#define GT 356
#define LT 357
#define GE 358
#define LE 359
#define LSH 360
#define RSH 361
#define UMIN 362
#define INCR 363
#define DECR 364
#define REDEF 365
#define GUNNY 366
#define YYERRCODE 256
typedef int YYINT;
static const YYINT xxlhs[] = {                           -1,
    0,    1,    2,    2,    3,    3,    3,    3,    3,    3,
    7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
    7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
    7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
    7,    7,    7,    7,    7,   15,   15,   15,   13,   13,
    6,    6,   12,   12,   18,   18,    9,    9,   17,   17,
    5,    5,   10,   10,   19,   19,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,   14,   14,   16,
   16,   16,   16,    8,    8,    8,    8,   11,   11,   20,
   20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
   20,   20,   20,   20,   20,   20,   20,
};
static const YYINT xxlen[] = {                            2,
    1,    3,    1,    2,    6,    5,    7,    6,    3,    2,
    3,    5,    4,    8,    2,    2,    2,    5,    2,    3,
    3,    6,    6,    3,    3,    4,    2,    2,    6,    6,
    4,    8,    8,    4,    4,    4,    4,    6,    6,    2,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    0,    1,    0,    1,    1,    3,    1,    3,    1,    3,
    0,    2,    1,    2,    1,    4,    3,    3,    3,    3,
    3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
    3,    3,    3,    3,    3,    2,    2,    2,    2,    1,
    4,    4,    6,    4,    8,    6,    8,    6,    6,    4,
    4,    4,    3,    4,    4,    4,    4,    6,    6,    4,
    4,    4,    4,    2,    2,    2,    3,    3,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    3,    2,    1,    1,    1,    3,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,
};
static const YYINT xxdefred[] = {                         0,
    0,    0,    1,    0,    0,    0,    0,    0,    0,   42,
   43,   45,   44,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  136,    0,    0,    0,    0,    0,    0,    0,  125,   90,
    0,  130,  131,    0,    0,    0,    0,  132,  133,    0,
    0,    0,    0,    0,  121,  124,    0,  122,  126,  127,
  123,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  120,
    0,    0,    0,   16,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   57,  154,  143,
  144,  148,  150,  155,  149,  153,  146,  145,  140,  141,
  142,  151,  152,  147,  156,  157,  135,    2,    4,   10,
    0,   27,   28,  134,    0,    0,    0,    9,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   87,   88,   86,   89,  114,  115,    0,
  116,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   49,    0,   50,    0,   24,
   25,    0,   20,    0,    0,   21,    0,  129,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   26,   66,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,  103,    0,    0,
   67,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  118,
  117,   59,    0,   52,    0,    0,    0,   31,   13,    0,
    0,    0,    0,    0,    0,    0,   35,   36,   34,   37,
   56,   58,    0,    0,    0,    6,    0,  113,  106,    0,
  111,  110,    0,    0,    0,  105,    0,    0,  107,  104,
   92,    0,   94,   91,  101,  102,  100,  112,    0,    0,
   18,    0,    0,    0,    0,    0,   46,   48,    0,   47,
    0,    0,    0,   12,    0,    5,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    8,   60,   29,   30,   22,
   23,    0,    0,    0,   38,   39,   62,    7,  108,  109,
    0,    0,   96,   98,   99,   93,    0,    0,    0,    0,
    0,   14,   32,   33,   95,   97,
};
#if defined(YYDESTRUCT_CALL) || defined(YYSTYPE_TOSTRING)
static const YYINT xxstos[] = {                           0,
  123,  368,  369,  259,  260,  263,  264,  266,  269,  270,
  271,  272,  273,  278,  297,  298,  310,  314,  315,  316,
  317,  322,  324,  325,  326,  327,  330,  331,  334,  335,
  336,  337,  341,  342,  344,   46,  370,  371,  375,  376,
  387,   46,   40,   58,   91,   40,   40,   40,  257,  258,
  259,  274,  275,  276,  277,  290,  299,  300,  301,  305,
  306,  307,  308,  309,  311,  312,  313,  318,  319,  320,
  321,  323,  328,  329,  332,  333,  338,  339,  340,  343,
  345,   45,  126,   33,   94,   64,   40,   35,  372,  376,
  378,  384,  387,  259,  259,  259,  372,   40,   40,   40,
   40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
   40,   40,   40,   40,   40,  259,  377,  386,  280,  281,
  282,  283,  284,  285,  286,  287,  288,  289,  291,  292,
  293,  294,  295,  296,  302,  303,  388,  125,  370,   59,
   61,  363,  364,  388,  372,  379,  380,  371,  379,  372,
  372,  259,   40,   40,   40,   40,   40,   40,   40,   40,
   40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
   40,   40,   40,  372,  372,  372,  372,  259,  303,  372,
  259,  349,  350,  351,  352,  354,  355,  356,  357,  358,
  359,  360,  361,   43,   45,   42,   47,   37,   94,  372,
   46,   64,   40,   91,  372,  257,  259,  311,  381,   41,
   41,  372,   41,  372,  372,   41,  372,   42,  372,  382,
  382,  259,  259,  259,  259,  372,  259,   91,   44,  304,
  372,   44,   41,   93,   41,   41,  265,  380,  259,  259,
  372,  258,  259,  376,  372,  372,  372,  372,  372,  376,
  372,  372,  372,  382,  382,  259,  259,   41,  259,  259,
   41,  372,  372,  372,  372,  372,  372,  372,  372,  372,
  372,  372,  372,  372,  372,  372,  372,  372,  372,  388,
  372,  259,  374,  385,  379,   44,   44,   41,   41,   44,
   44,   44,   44,   44,   44,   44,   41,   41,   41,   41,
   93,  386,   40,  372,  369,  369,  259,   41,   41,   44,
   41,   41,   44,   44,   44,   41,   44,   44,   41,   41,
   41,   44,   41,   41,   41,   41,   41,   41,   41,   44,
   93,  372,  381,  372,  372,  372,  259,   46,  383,  384,
  383,  372,  372,   41,  262,  373,   41,  372,  258,  372,
  258,  259,  258,  258,  372,  369,  259,   41,   41,   41,
   41,   44,   44,   44,   41,   41,  369,  369,   41,   41,
   44,   44,   41,   41,   41,   41,  372,  383,  383,  372,
  259,   41,   41,   41,   41,   41,
};
#endif /* YYDESTRUCT_CALL || YYSTYPE_TOSTRING */
static const YYINT xxdgoto[] = {                          2,
    3,   37,   38,  145,  346,  283,   39,   90,  117,   91,
  146,  147,  209,  220,  339,   92,  284,  118,   93,  137,
};
static const YYINT xxsindex[] = {                       -92,
 4202,    0,    0,   79,   22,   38,   40, 3814, -215,    0,
    0,    0,    0, -205, -166, 3814,   62,   69,   80,   83,
   86,   87,   88,   92,   95,  102,  103,  104,  105,  107,
  109,  115,  125,  128, -135, 1123,   44, 4202,  112,  -47,
    0, 1123, 3814, 4202, 3814, 3814, 3814, -120,    0,    0,
   -6,    0,    0,  133,  152,  157,  158,    0,    0,  159,
  160,  161,  162,  163,    0,    0,  164,    0,    0,    0,
    0,  165,  166,  167,  168,  169,  170,  172,  174,  187,
  188, 3814, 3814, 3814, 3814, -234, 3814,  -30, 2634,    0,
 3814,  184,  171,    0,  191,  141, 2634, 3814, -216,  192,
  193, 3814,  195, 3814, 3814,  197, 3814, 3722, 3722,  -20,
  -19,  -18,  -16, 3814,  -15,  154,  202,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 3625,    0,    0,    0, 2634,  203,  207,    0,  -29,  213,
  232,  -13, 3814,   -2,    2, 3814,  -42, 3814, 3814, 3814,
 3814, 3814,  -33, 3814, 3814, 3814, 3722, 3722,    3,    6,
  208,    7,    8,    0,    0,    0,    0,    0,    0,  254,
    0, 3814, 3814, 3814, 3814, 3814, 3814, 3814, 3814, 3814,
 3814, 3814, 3814, 3814, 3814, 3814, 3814, 3814, 3814, 2634,
 1123, 3814,   17, 3814,  268,    0,  209,    0,  210,    0,
    0,  401,    0,  419,  625,    0,  641,    0, 2634,  215,
  219,  220,  224,  229,  239,  669,  240,  196, -135,  245,
 2634, 3814,    0,    0,  -92,  -92,   27,  249,  251,  250,
 1086,  252,  -26,  256, 1210, 1385, 2131, 2224, 2237,  257,
 2251, 2334, 2347,  262,  267,  291,  300,    0,  301,  308,
    0,  653,  -21,  -36,  -36, 1250, 1250,  -10,  -10,  -10,
  -10,   14,   14,   99,   99,  261,  261,  261,  261,    0,
    0,    0,   19,    0,  -25, 3814, -245,    0,    0, 3814,
 3814, 3814,   84,   84, 3814, 3814,    0,    0,    0,    0,
    0,    0,  315, 2634,   47,    0,  316,    0,    0, 3814,
    0,    0,  106, 3814, -167,    0,  108,  110,    0,    0,
    0, 3814,    0,    0,    0,    0,    0,    0,  -92,  113,
    0, 2361,  320, 2456, 2469, 2483,    0,    0,  321,    0,
  323, 2496, 2510,    0,  -92,    0,  -92, 2523,  332, 2576,
  330,  339,  345,  346, 2593,    0,    0,    0,    0,    0,
    0, 3814,   84,   84,    0,    0,    0,    0,    0,    0,
 3814,  135,    0,    0,    0,    0, 2606,  351,  354, 2620,
  355,    0,    0,    0,    0,    0,
};
static const YYINT xxrindex[] = {                         0,
    0,    0,    0,  -11,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  338,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   70,    0,  275,    0,    0,
    0,    0,  360,    0,    0,    0,    0,    0,    0,    0,
 1197,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0, 3926,    0,
  347,  178,  507,    0,    0,  348,  352,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  -14,  353,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    5,  363,    0,    0,    0,    0,
    0,    0,  360,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, 4023,
    0,    0,   26,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   45,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  357,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   77,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, 3470, 3392, 3141, 3303, 2963, 3052, 1780, 1890, 2001,
 2111, 1559, 1669, 1338, 1448,  612,  758,  863, 1009,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   11, 4115,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,
};
#if YYBTYACC
static const YYINT xxcindex[] = {                         0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,
};
#endif
static const YYINT xxgindex[] = {                         0,
 -207,  367,  370,   -8,    0,    0,    0,    4,    0,    0,
   -9,  264,  131,  -86, -292, -276,    0,  194,    9,  -39,
};
#define YYTABLESIZE 4546
static const YYINT xxtable[] = {                         89,
  198,  341,  144,   36,   40,  196,  194,   97,  195,   41,
  197,  206,   36,  141,  232,  198,  340,  340,  232,   42,
  196,  194,  221,  195,  178,  197,  198,  305,  306,   55,
    1,  196,  194,  153,  195,  149,  197,  150,  151,   42,
  206,   40,  207,   94,   55,  138,   41,   40,  138,   65,
  198,  139,   41,   95,  139,  196,  194,  199,  195,  329,
  197,   46,  330,  234,   45,  208,   51,  331,  179,   51,
  378,  379,  199,  174,  175,  176,  177,   47,  180,   48,
  254,  255,  200,  199,   45,  128,  340,  340,  128,  205,
  351,  352,   96,  212,  208,  214,  215,  138,  217,  219,
  219,   98,  137,  139,  137,  226,  137,  199,   99,  137,
  137,  137,  137,  137,  137,  137,  137,   65,   43,  100,
   65,  356,  101,  116,   42,  102,  103,  104,  137,  338,
  137,  105,  231,  137,  106,  198,   44,  367,  152,  368,
  196,  107,  108,  109,  110,  197,  111,  241,  112,  245,
  246,  247,  248,  249,  113,  251,  252,  253,  219,  219,
  244,  280,  137,  137,  114,   41,  250,  115,  138,   45,
  140,   41,  154,  262,  263,  264,  265,  266,  267,  268,
  269,  270,  271,  272,  273,  274,  275,  276,  277,  278,
  279,  155,  199,  281,  285,  137,  156,  157,  158,  159,
  160,  161,  162,  163,  164,  165,  166,  167,  168,  169,
  119,  170,  119,  171,  119,  242,  243,  119,  119,  119,
  119,  119,  119,  304,  119,  243,  172,  173,  181,  201,
  203,  204,  210,  211,  202,  213,  119,  216,  222,  223,
  224,  119,  225,  227,  228,  229,  232,  233,  258,  198,
  288,  237,  287,  235,  196,  194,  239,  195,  293,  197,
  240,  256,  294,  295,  257,  259,  260,  296,  198,  297,
  119,  119,  236,  196,  194,  282,  195,  332,  197,  298,
  300,  334,  335,  336,  303,  307,  342,  343,  301,  308,
  198,  309,  312,  310,  261,  196,  194,  319,  195,  313,
  197,  348,  323,  119,  198,  350,  199,  324,  345,  196,
  194,  286,  195,  355,  197,  142,  143,  186,  187,  188,
  189,  190,  191,  192,  193,  199,  137,  137,  137,  184,
  185,  325,  186,  187,  188,  189,  190,  191,  192,  193,
  326,  327,  337,  137,  137,  137,  137,  199,  328,  192,
  193,   65,   65,  377,  199,  344,  347,   52,   53,  137,
  359,  199,  380,  349,  363,  353,  364,  354,  137,  137,
  137,  357,  370,  372,  137,  137,  137,  137,  137,  373,
  137,  137,  137,   58,   59,  374,  375,  137,  137,  137,
  137,  383,  137,  381,  384,  386,   41,  137,  137,    3,
   53,  137,  137,   54,  139,   17,   19,  137,  137,  137,
   40,   15,  137,  148,  137,   11,  238,  333,  137,  137,
  137,  137,  302,  137,  137,  137,  137,  137,  137,  137,
  137,    0,  137,  137,  119,  119,  119,  198,    0,    0,
    0,  289,  196,  194,    0,  195,    0,  197,    0,    0,
    0,  119,  119,  119,  119,  198,    0,    0,    0,    0,
  196,  194,  290,  195,    0,  197,    0,  119,    0,    0,
    0,    0,    0,    0,    0,    0,  119,  119,  119,    0,
    0,    0,  119,  119,  119,  119,  119,    0,  119,  119,
  119,    0,    0,    0,  199,  119,  119,  119,  119,    0,
  119,    0,    0,    0,    0,  119,  119,    0,    0,  119,
  119,    0,  199,    0,    0,  119,  119,  119,    0,    0,
  119,    0,  119,    0,    0,    0,  119,  119,  119,  119,
    0,  119,  119,  119,  119,  119,  119,  119,  119,  136,
    0,  136,    0,  136,    0,    0,  136,  136,  136,  136,
  136,  136,  136,  136,    0,    0,    0,    0,    0,    0,
    0,  182,  183,  184,  185,  136,  186,  187,  188,  189,
  190,  191,  192,  193,    0,    0,    0,    0,    0,    0,
  182,  183,  184,  185,    0,  186,  187,  188,  189,  190,
  191,  192,  193,    0,    0,    0,    0,    0,    0,  136,
  136,    0,  182,  183,  184,  185,    0,  186,  187,  188,
  189,  190,  191,  192,  193,    0,  182,  183,  184,  185,
    0,  186,  187,  188,  189,  190,  191,  192,  193,    0,
    0,    0,  136,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   78,    0,   78,    0,   78,    0,
    0,   78,   78,   78,   78,   78,   78,   78,   78,    0,
    0,  198,    0,    0,    0,    0,  196,  194,  291,  195,
   78,  197,    0,    0,    0,   78,    0,  198,    0,    0,
    0,    0,  196,  194,  292,  195,    0,  197,    0,  198,
    0,    0,    0,    0,  196,  194,    0,  195,    0,  197,
    0,    0,    0,    0,   78,  198,    0,    0,    0,  299,
  196,  194,    0,  195,    0,  197,    0,    0,  199,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  199,    0,    0,   78,    0,    0,
    0,    0,    0,    0,    0,    0,  199,    0,    0,  182,
  183,  184,  185,    0,  186,  187,  188,  189,  190,  191,
  192,  193,  199,  136,  136,  136,    0,  182,  183,  184,
  185,    0,  186,  187,  188,  189,  190,  191,  192,  193,
  136,  136,  136,  136,    0,    0,    0,    0,    0,    0,
   79,    0,   79,    0,   79,    0,  136,   79,   79,   79,
   79,   79,   79,   79,   79,  136,  136,  136,    0,    0,
    0,  136,  136,  136,  136,  136,   79,  136,  136,  136,
    0,   79,    0,    0,  136,  136,  136,  136,    0,  136,
    0,    0,    0,    0,  136,  136,    0,    0,  136,  136,
    0,    0,    0,    0,  136,  136,  136,    0,    0,  136,
   79,  136,    0,    0,    0,  136,  136,  136,  136,    0,
  136,  136,  136,  136,  136,  136,  136,  136,   78,   78,
   78,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   79,    0,   78,   78,   78,   78,    0,
    0,    0,    0,    0,    0,   80,    0,   80,    0,   80,
    0,   78,   80,   80,   80,   80,   80,   80,   80,   80,
   78,   78,   78,    0,    0,    0,   78,   78,   78,   78,
   78,   80,   78,   78,   78,    0,   80,    0,    0,   78,
   78,   78,   78,    0,   78,    0,    0,    0,    0,   78,
   78,    0,    0,   78,   78,    0,    0,    0,    0,   78,
   78,   78,    0,    0,   78,   80,   78,    0,    0,    0,
   78,   78,   78,   78,    0,   78,   78,   78,   78,   78,
   78,   78,   78,  182,  183,  184,  185,    0,  186,  187,
  188,  189,  190,  191,  192,  193,    0,    0,   80,  182,
  183,  184,  185,    0,  186,  187,  188,  189,  190,  191,
  192,  193,  183,  184,  185,    0,  186,  187,  188,  189,
  190,  191,  192,  193,   79,   79,   79,  182,  183,  184,
  185,    0,  186,  187,  188,  189,  190,  191,  192,  193,
    0,   79,   79,   79,   79,    0,    0,    0,    0,    0,
    0,   83,    0,   83,    0,   83,    0,   79,   83,   83,
   83,   83,   83,   83,   83,   83,   79,   79,   79,    0,
    0,    0,   79,   79,   79,   79,   79,   83,   79,   79,
   79,    0,   83,    0,    0,   79,   79,   79,   79,    0,
   79,    0,    0,    0,    0,   79,   79,    0,    0,   79,
   79,    0,    0,    0,    0,   79,   79,   79,    0,    0,
   79,   83,   79,    0,    0,    0,   79,   79,   79,   79,
    0,   79,   79,   79,   79,   79,   79,   79,   79,   80,
   80,   80,  198,    0,    0,    0,  311,  196,  194,    0,
  195,    0,  197,    0,   83,    0,   80,   80,   80,   80,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   80,    0,    0,    0,    0,    0,    0,    0,
    0,   80,   80,   80,    0,    0,    0,   80,   80,   80,
   80,   80,    0,   80,   80,   80,    0,    0,    0,  199,
   80,   80,   80,   80,    0,   80,    0,    0,    0,    0,
   80,   80,    0,    0,   80,   80,    0,    0,    0,    0,
   80,   80,   80,    0,    0,   80,    0,   80,    0,    0,
    0,   80,   80,   80,   80,    0,   80,   80,   80,   80,
   80,   80,   80,   80,    0,    0,    0,    0,    0,   65,
    0,   65,    0,   65,    0,    0,    0,   65,   65,   65,
   65,   65,    0,   65,    0,    0,  198,    0,    0,    0,
    0,  196,  194,  314,  195,   65,  197,    0,    0,    0,
   65,    0,    0,    0,    0,   83,   83,   83,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   83,   83,   83,   83,  198,    0,    0,   65,
   65,  196,  194,    0,  195,    0,  197,    0,   83,    0,
    0,    0,    0,  199,    0,    0,    0,   83,   83,   83,
    0,    0,    0,   83,   83,   83,   83,   83,    0,   83,
   83,   83,   65,    0,    0,    0,   83,   83,   83,   83,
    0,   83,    0,    0,    0,    0,   83,   83,    0,    0,
   83,   83,    0,  199,    0,    0,   83,   83,   83,    0,
    0,   83,    0,   83,    0,    0,    0,   83,   83,   83,
   83,    0,   83,   83,   83,   83,   83,   83,   83,   83,
   76,    0,   76,    0,    0,    0,    0,   76,   76,    0,
   76,   76,   76,   76,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   76,    0,    0,    0,
    0,   76,  119,  120,  121,  122,  123,  124,  125,  126,
  127,  128,    0,  129,  130,  131,  132,  133,  134,    0,
    0,  198,    0,    0,  135,  136,  196,  194,  315,  195,
   76,  197,    0,    0,  182,  183,  184,  185,    0,  186,
  187,  188,  189,  190,  191,  192,  193,    0,    0,    0,
    0,    0,    0,   65,   65,   65,    0,    0,    0,    0,
    0,    0,    0,   76,    0,    0,    0,    0,    0,    0,
   65,   65,   65,   65,    0,    0,    0,    0,  199,    0,
   77,    0,   77,    0,    0,    0,   65,   77,   77,    0,
   77,   77,   77,   77,    0,   65,   65,   65,    0,    0,
    0,   65,   65,   65,   65,   65,   77,   65,   65,   65,
    0,   77,    0,    0,   65,   65,   65,   65,    0,   65,
    0,    0,    0,    0,   65,   65,    0,    0,   65,   65,
    0,    0,    0,    0,   65,   65,   65,    0,    0,   65,
   77,   65,    0,    0,    0,   65,   65,   65,   65,    0,
   65,   65,   65,   65,   65,   65,   65,   65,  182,  183,
  184,  185,    0,  186,  187,  188,  189,  190,  191,  192,
  193,    0,    0,   77,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   84,    0,   84,   76,   76,   76,    0,   84,   84,
    0,    0,   84,    0,   84,  188,  189,  190,  191,  192,
  193,   76,   76,   76,   76,    0,    0,   84,    0,    0,
    0,    0,   84,    0,    0,    0,    0,   76,    0,    0,
    0,    0,    0,    0,    0,    0,   76,   76,   76,    0,
    0,    0,   76,   76,   76,   76,   76,    0,   76,   76,
   76,   84,    0,    0,    0,   76,   76,   76,   76,    0,
   76,    0,    0,    0,    0,   76,   76,    0,    0,   76,
   76,    0,    0,    0,    0,   76,   76,   76,    0,    0,
   76,    0,   76,    0,   84,    0,   76,   76,   76,   76,
    0,   76,   76,   76,   76,   76,   76,   76,   76,    0,
    0,   85,    0,   85,   77,   77,   77,    0,   85,   85,
    0,    0,   85,    0,   85,    0,    0,    0,    0,    0,
    0,   77,   77,   77,   77,    0,    0,   85,    0,    0,
    0,    0,   85,  182,  183,  184,  185,   77,  186,  187,
  188,  189,  190,  191,  192,  193,   77,   77,   77,    0,
    0,    0,   77,   77,   77,   77,   77,    0,   77,   77,
   77,   85,    0,    0,    0,   77,   77,   77,   77,    0,
   77,    0,    0,    0,    0,   77,   77,    0,    0,   77,
   77,    0,    0,    0,    0,   77,   77,   77,    0,    0,
   77,    0,   77,    0,   85,    0,   77,   77,   77,   77,
    0,   77,   77,   77,   77,   77,   77,   77,   77,    0,
    0,    0,   68,    0,   68,   84,   84,   84,    0,   68,
   68,    0,    0,   68,    0,   68,    0,    0,    0,    0,
    0,    0,   84,   84,   84,   84,    0,    0,   68,    0,
    0,    0,    0,   68,    0,    0,    0,    0,   84,    0,
    0,    0,    0,    0,    0,    0,    0,   84,   84,   84,
    0,    0,    0,   84,   84,   84,   84,   84,    0,   84,
   84,   84,   68,    0,    0,    0,   84,   84,   84,   84,
    0,   84,    0,    0,    0,    0,   84,   84,    0,    0,
   84,   84,    0,    0,    0,    0,   84,   84,   84,    0,
    0,   84,    0,   84,    0,   68,    0,   84,   84,   84,
   84,    0,   84,   84,   84,   84,   84,   84,   84,   84,
    0,    0,   70,    0,   70,   85,   85,   85,    0,   70,
   70,    0,    0,   70,    0,   70,    0,    0,    0,    0,
    0,    0,   85,   85,   85,   85,    0,    0,   70,    0,
    0,    0,    0,   70,    0,    0,    0,    0,   85,    0,
    0,    0,    0,    0,    0,    0,    0,   85,   85,   85,
    0,    0,    0,   85,   85,   85,   85,   85,    0,   85,
   85,   85,   70,    0,    0,    0,   85,   85,   85,   85,
    0,   85,    0,    0,    0,    0,   85,   85,    0,    0,
   85,   85,    0,    0,    0,    0,   85,   85,   85,    0,
    0,   85,    0,   85,    0,   70,    0,   85,   85,   85,
   85,    0,   85,   85,   85,   85,   85,   85,   85,   85,
    0,    0,    0,   69,    0,   69,   68,   68,   68,    0,
   69,   69,    0,    0,   69,    0,   69,    0,    0,    0,
    0,    0,    0,   68,   68,   68,   68,    0,    0,   69,
    0,    0,    0,    0,   69,    0,    0,    0,    0,   68,
    0,    0,    0,    0,    0,    0,    0,    0,   68,   68,
   68,    0,    0,    0,   68,   68,   68,   68,   68,    0,
   68,   68,   68,   69,    0,    0,    0,   68,   68,   68,
   68,    0,   68,    0,    0,    0,    0,   68,   68,    0,
    0,   68,   68,    0,    0,    0,    0,   68,   68,   68,
    0,    0,   68,    0,   68,    0,   69,    0,   68,   68,
   68,   68,    0,   68,   68,   68,   68,   68,   68,    0,
    0,    0,    0,   71,    0,   71,   70,   70,   70,    0,
   71,   71,    0,    0,   71,    0,   71,    0,    0,    0,
    0,    0,    0,   70,   70,   70,   70,  198,    0,   71,
    0,  316,  196,  194,   71,  195,    0,  197,    0,   70,
    0,    0,    0,    0,    0,    0,    0,    0,   70,   70,
   70,    0,    0,    0,   70,   70,   70,   70,   70,    0,
   70,   70,   70,   71,    0,    0,    0,   70,   70,   70,
   70,    0,   70,    0,    0,    0,    0,   70,   70,    0,
    0,   70,   70,    0,  199,    0,    0,   70,   70,   70,
    0,    0,   70,    0,   70,    0,   71,    0,   70,   70,
   70,   70,    0,   70,   70,   70,   70,   70,   70,    0,
    0,    0,    0,    0,    0,    0,    0,   69,   69,   69,
  198,    0,    0,    0,    0,  196,  194,  317,  195,    0,
  197,    0,    0,  198,   69,   69,   69,   69,  196,  194,
  318,  195,    0,  197,    0,    0,    0,  198,    0,    0,
   69,  320,  196,  194,    0,  195,    0,  197,    0,   69,
   69,   69,    0,    0,    0,   69,   69,   69,   69,   69,
    0,   69,   69,   69,    0,    0,    0,  199,   69,   69,
   69,   69,    0,   69,    0,    0,    0,    0,   69,   69,
  199,    0,   69,   69,    0,    0,    0,    0,   69,   69,
   69,    0,    0,   69,  199,   69,    0,    0,    0,   69,
   69,   69,   69,    0,   69,   69,   69,   69,   69,   69,
    0,    0,    0,    0,    0,    0,    0,   71,   71,   71,
  198,    0,    0,    0,  321,  196,  194,    0,  195,    0,
  197,    0,    0,  198,   71,   71,   71,   71,  196,  194,
  322,  195,    0,  197,    0,    0,    0,  198,    0,    0,
   71,  358,  196,  194,    0,  195,    0,  197,    0,   71,
   71,   71,    0,    0,    0,   71,   71,   71,   71,   71,
    0,   71,   71,   71,    0,    0,    0,  199,   71,   71,
   71,   71,    0,   71,    0,    0,    0,    0,   71,   71,
  199,    0,   71,   71,    0,    0,    0,    0,   71,   71,
   71,    0,    0,   71,  199,   71,    0,    0,    0,   71,
   71,   71,   71,    0,   71,   71,   71,   71,   71,   71,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  182,
  183,  184,  185,    0,  186,  187,  188,  189,  190,  191,
  192,  193,  198,    0,    0,    0,  360,  196,  194,    0,
  195,    0,  197,    0,    0,  198,    0,    0,    0,  361,
  196,  194,    0,  195,    0,  197,    0,    0,    0,  198,
    0,    0,    0,    0,  196,  194,  362,  195,    0,  197,
    0,    0,  198,    0,    0,    0,  365,  196,  194,    0,
  195,    0,  197,    0,    0,    0,  198,    0,    0,  199,
  366,  196,  194,    0,  195,    0,  197,    0,    0,  198,
    0,    0,  199,  369,  196,  194,    0,  195,    0,  197,
    0,    0,  182,  183,  184,  185,  199,  186,  187,  188,
  189,  190,  191,  192,  193,  182,  183,  184,  185,  199,
  186,  187,  188,  189,  190,  191,  192,  193,    0,  182,
  183,  184,  185,  199,  186,  187,  188,  189,  190,  191,
  192,  193,  198,    0,    0,    0,  199,  196,  194,  371,
  195,    0,  197,    0,    0,    0,    0,    0,    0,  198,
    0,    0,    0,  376,  196,  194,    0,  195,    0,  197,
    0,    0,  198,    0,    0,    0,  382,  196,  194,    0,
  195,    0,  197,    0,    0,    0,  198,    0,    0,    0,
  385,  196,  194,    0,  195,    0,  197,    0,    0,  199,
  198,    0,    0,    0,    0,  196,  194,    0,  195,    0,
  197,    0,  182,  183,  184,  185,  199,  186,  187,  188,
  189,  190,  191,  192,  193,  182,  183,  184,  185,  199,
  186,  187,  188,  189,  190,  191,  192,  193,    0,  182,
  183,  184,  185,  199,  186,  187,  188,  189,  190,  191,
  192,  193,    0,    0,    0,    0,    0,  199,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  182,  183,  184,  185,    0,  186,
  187,  188,  189,  190,  191,  192,  193,  182,  183,  184,
  185,    0,  186,  187,  188,  189,  190,  191,  192,  193,
    0,  182,  183,  184,  185,    0,  186,  187,  188,  189,
  190,  191,  192,  193,  182,  183,  184,  185,    0,  186,
  187,  188,  189,  190,  191,  192,  193,    0,  182,  183,
  184,  185,    0,  186,  187,  188,  189,  190,  191,  192,
  193,  182,  183,  184,  185,    0,  186,  187,  188,  189,
  190,  191,  192,  193,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  182,  183,  184,  185,    0,  186,
  187,  188,  189,  190,  191,  192,  193,    0,    0,    0,
    0,  182,  183,  184,  185,    0,  186,  187,  188,  189,
  190,  191,  192,  193,  182,  183,  184,  185,    0,  186,
  187,  188,  189,  190,  191,  192,  193,    0,  182,  183,
  184,  185,    0,  186,  187,  188,  189,  190,  191,  192,
  193,    0,  182,  183,  184,  185,    0,  186,  187,  188,
  189,  190,  191,  192,  193,   72,    0,   72,    0,    0,
    0,    0,   72,   72,    0,    0,   72,    0,   72,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   72,    0,    0,    0,    0,   72,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   72,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   73,    0,   73,    0,   72,    0,
    0,   73,   73,    0,    0,   73,    0,   73,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   73,    0,    0,    0,    0,   73,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   73,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   81,    0,   81,    0,   73,    0,    0,
   81,   81,    0,    0,   81,    0,   81,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   81,
    0,    0,    0,    0,   81,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   72,
   72,   72,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   81,    0,    0,   72,   72,   72,   72,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   72,    0,    0,    0,    0,    0,    0,    0,
    0,   72,   72,   72,    0,    0,   81,   72,   72,   72,
   72,   72,    0,   72,   72,   72,    0,    0,    0,    0,
   72,   72,   72,   72,    0,   72,    0,    0,    0,    0,
   72,   72,    0,    0,   72,   72,    0,    0,    0,    0,
   72,   72,   72,    0,    0,   72,    0,   72,   73,   73,
   73,   72,   72,   72,   72,    0,   72,   72,    0,    0,
    0,    0,    0,    0,    0,   73,   73,   73,   73,    0,
    0,    0,    0,    0,    0,   82,    0,   82,    0,    0,
    0,   73,   82,   82,    0,    0,   82,    0,   82,    0,
   73,   73,   73,    0,    0,    0,   73,   73,   73,   73,
   73,   82,   73,   73,   73,    0,   82,    0,    0,   73,
   73,   73,   73,    0,   73,    0,    0,    0,    0,   73,
   73,    0,    0,   73,   73,    0,    0,    0,    0,   73,
   73,   73,    0,    0,   73,   82,   73,   81,   81,   81,
   73,   73,   73,   73,    0,   73,   73,    0,    0,    0,
    0,    0,    0,    0,   81,   81,   81,   81,    0,    0,
    0,    0,    0,    0,   75,    0,   75,    0,   82,    0,
   81,   75,   75,    0,    0,   75,    0,   75,    0,   81,
   81,   81,    0,    0,    0,   81,   81,   81,   81,   81,
   75,   81,   81,   81,    0,   75,    0,    0,   81,   81,
   81,   81,    0,   81,    0,    0,    0,    0,   81,   81,
    0,    0,   81,   81,    0,    0,    0,    0,   81,   81,
   81,    0,    0,   81,   75,   81,    0,    0,    0,   81,
   81,   81,   81,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   74,    0,   74,    0,    0,    0,    0,   74,
   74,    0,    0,   74,    0,   74,    0,   75,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   74,    0,
    0,    0,    0,   74,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   82,
   82,   82,   74,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   82,   82,   82,   82,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   82,    0,    0,   74,    0,    0,    0,    0,
    0,   82,   82,   82,    0,    0,    0,   82,   82,   82,
   82,   82,    0,   82,   82,   82,    0,    0,    0,    0,
   82,   82,   82,   82,    0,   82,    0,    0,    0,    0,
   82,   82,    0,    0,   82,   82,    0,    0,    0,    0,
   82,   82,   82,    0,    0,   82,    0,   82,   75,   75,
   75,   82,   82,   82,   82,    0,    0,   84,    0,   88,
    0,    0,    0,    0,   87,   75,   75,   75,   75,   82,
   36,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   75,    0,    0,    0,    0,    0,    0,   86,    0,
   75,   75,   75,    0,    0,    0,   75,   75,   75,   75,
   75,    0,   75,   75,   75,    0,    0,    0,    0,   75,
   75,   75,   75,    0,   75,    0,    0,    0,   85,   75,
   75,    0,    0,   75,   75,    0,   74,   74,   74,   75,
   75,   75,    0,    0,   75,    0,   75,    0,    0,    0,
   75,   75,    0,   74,   74,   74,   74,    0,    0,    0,
   83,    0,    0,    0,   84,    0,   88,    0,    0,   74,
    0,   87,    0,  218,    0,    0,   82,   36,   74,   74,
   74,    0,    0,    0,   74,   74,   74,   74,   74,    0,
   74,   74,   74,    0,    0,   86,    0,   74,   74,   74,
   74,    0,   74,    0,    0,    0,    0,   74,   74,    0,
    0,   74,   74,    0,    0,    0,    0,   74,   74,   74,
    0,    0,   74,    0,   74,   85,    0,    0,   74,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   84,   83,   88,    0,
    0,    0,    0,   87,    0,    0,    0,    0,   82,   36,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   86,    0,    0,
    0,   49,   50,   51,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   52,   53,
   54,   55,    0,    0,    0,    0,    0,   85,    0,    0,
    0,    0,    0,    0,   56,    0,    0,    0,    0,    0,
    0,    0,    0,   57,   58,   59,    0,    0,  230,   60,
   61,   62,   63,   64,    0,   65,   66,   67,    0,   83,
    0,    0,   68,   69,   70,   71,    0,   72,    0,    0,
    0,    0,   73,   74,    0,    0,   75,   76,   63,    0,
   63,    0,   77,   78,   79,   63,    0,   80,    0,   81,
    0,   63,    0,    0,    0,    0,    0,    0,   49,   50,
   51,    0,    0,    0,   63,    0,    0,    0,    0,   63,
    0,    0,    0,    0,    0,   52,   53,   54,   55,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   56,    0,    0,    0,    0,    0,    0,    0,    0,
   57,   58,   59,    0,    0,    0,   60,   61,   62,   63,
   64,    0,   65,   66,   67,    0,    0,    0,    0,   68,
   69,   70,   71,    0,   72,    0,    0,    0,    0,   73,
   74,   63,    0,   75,   76,   64,    0,   64,    0,   77,
   78,   79,   64,    0,   80,    0,   81,    0,   64,    0,
   49,   50,   51,    0,    0,    0,    0,    0,    0,    0,
    0,   64,    0,    0,    0,    0,   64,   52,   53,   54,
   55,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   56,    0,    0,    0,    0,    0,    0,
    0,    0,   57,   58,   59,    0,    0,    0,   60,   61,
   62,   63,   64,    0,   65,   66,   67,    0,    0,    0,
    0,   68,   69,   70,   71,    0,   72,    0,    0,    0,
    0,   73,   74,    0,    0,   75,   76,    0,   64,    0,
    0,   77,   78,   79,    0,    0,   80,    0,   81,    0,
   61,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   63,   63,   63,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   63,
   63,   63,   63,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   63,    0,    0,    0,    0,
    0,    0,    0,    0,   63,   63,   63,    0,    0,    0,
   63,   63,   63,   63,   63,    0,   63,   63,   63,   61,
    0,    0,    0,   63,   63,   63,   63,   36,   63,    0,
    0,    0,    0,   63,   63,    0,    0,   63,   63,    0,
    0,    0,    0,   63,   63,   63,    0,    0,   63,    0,
   63,    0,    0,    0,    0,    0,    0,    0,    0,   64,
   64,   64,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   64,   64,   64,   64,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   64,    0,    0,    0,    0,    0,    0,    0,
    0,   64,   64,   64,    0,    0,    0,   64,   64,   64,
   64,   64,    0,   64,   64,   64,    0,    0,    0,    0,
   64,   64,   64,   64,    0,   64,    0,    0,    0,    0,
   64,   64,    0,    0,   64,   64,    0,    0,    0,    0,
   64,   64,   64,    0,    0,   64,    0,   64,    0,    0,
    0,    0,    0,   61,   61,    0,    0,   61,   61,    0,
   61,    0,    0,   61,   61,   61,   61,   61,    0,    0,
    0,    0,   61,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   61,   61,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   61,    0,    0,    0,   61,   61,
   61,   61,    0,    0,    0,    0,   61,    0,   61,   61,
   61,   61,    0,    0,   61,   61,    0,    0,   61,   61,
   61,   61,    0,    0,    0,   61,   61,    0,   61,    0,
    4,    5,    0,    0,    6,    7,    0,    8,    0,    0,
    9,   10,   11,   12,   13,    0,    0,    0,    0,   14,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   15,   16,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   17,    0,    0,    0,   18,   19,   20,   21,    0,
    0,    0,    0,   22,    0,   23,   24,   25,   26,    0,
    0,   27,   28,    0,    0,   29,   30,   31,   32,    0,
    0,    0,   33,   34,    0,   35,
};
static const YYINT xxcheck[] = {                          8,
   37,  294,   42,   46,    1,   42,   43,   16,   45,    1,
   47,  257,   46,   61,   44,   37,  293,  294,   44,   46,
   42,   43,  109,   45,  259,   47,   37,  235,  236,   44,
  123,   42,   43,   40,   45,   45,   47,   46,   47,   46,
  257,   38,  259,  259,   59,   41,   38,   44,   44,   61,
   37,   41,   44,  259,   44,   42,   43,   94,   45,   41,
   47,   40,   44,   93,   91,  311,   41,   93,  303,   44,
  363,  364,   94,   82,   83,   84,   85,   40,   87,   40,
  167,  168,   91,   94,   91,   41,  363,  364,   44,   98,
  258,  259,  259,  102,  311,  104,  105,   93,  107,  108,
  109,   40,   33,   93,   35,  114,   37,   94,   40,   40,
   41,   42,   43,   44,   45,   46,   47,   41,   40,   40,
   44,  329,   40,  259,   46,   40,   40,   40,   59,   46,
   61,   40,  141,   64,   40,   37,   58,  345,  259,  347,
   42,   40,   40,   40,   40,   47,   40,  156,   40,  158,
  159,  160,  161,  162,   40,  164,  165,  166,  167,  168,
  157,  201,   93,   94,   40,  157,  163,   40,  125,   91,
   59,  163,   40,  182,  183,  184,  185,  186,  187,  188,
  189,  190,  191,  192,  193,  194,  195,  196,  197,  198,
  199,   40,   94,  202,  204,  126,   40,   40,   40,   40,
   40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
   33,   40,   35,   40,   37,  258,  259,   40,   41,   42,
   43,   44,   45,  232,   47,  259,   40,   40,  259,   46,
   40,   91,   41,   41,   64,   41,   59,   41,  259,  259,
  259,   64,  259,  259,   91,   44,   44,   41,   41,   37,
   41,  265,   44,   41,   42,   43,  259,   45,   44,   47,
  259,  259,   44,   44,  259,  259,  259,   44,   37,   41,
   93,   94,   41,   42,   43,  259,   45,  286,   47,   41,
   41,  290,  291,  292,   40,  259,  295,  296,   93,   41,
   37,   41,   41,   44,   41,   42,   43,   41,   45,   44,
   47,  310,   41,  126,   37,  314,   94,   41,  262,   42,
   43,   44,   45,  322,   47,  363,  364,  354,  355,  356,
  357,  358,  359,  360,  361,   94,  257,  258,  259,  351,
  352,   41,  354,  355,  356,  357,  358,  359,  360,  361,
   41,   41,  259,  274,  275,  276,  277,   94,   41,  360,
  361,  363,  364,  362,   94,   41,   41,  274,  275,  290,
   41,   94,  371,  258,   44,  258,   44,  258,  299,  300,
  301,  259,   41,   44,  305,  306,  307,  308,  309,   41,
  311,  312,  313,  300,  301,   41,   41,  318,  319,  320,
  321,   41,  323,  259,   41,   41,   59,  328,  329,  125,
   41,  332,  333,   41,   38,   59,   59,  338,  339,  340,
   59,   59,  343,   44,  345,   59,  153,  287,  349,  350,
  351,  352,  229,  354,  355,  356,  357,  358,  359,  360,
  361,   -1,  363,  364,  257,  258,  259,   37,   -1,   -1,
   -1,   41,   42,   43,   -1,   45,   -1,   47,   -1,   -1,
   -1,  274,  275,  276,  277,   37,   -1,   -1,   -1,   -1,
   42,   43,   44,   45,   -1,   47,   -1,  290,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  299,  300,  301,   -1,
   -1,   -1,  305,  306,  307,  308,  309,   -1,  311,  312,
  313,   -1,   -1,   -1,   94,  318,  319,  320,  321,   -1,
  323,   -1,   -1,   -1,   -1,  328,  329,   -1,   -1,  332,
  333,   -1,   94,   -1,   -1,  338,  339,  340,   -1,   -1,
  343,   -1,  345,   -1,   -1,   -1,  349,  350,  351,  352,
   -1,  354,  355,  356,  357,  358,  359,  360,  361,   33,
   -1,   35,   -1,   37,   -1,   -1,   40,   41,   42,   43,
   44,   45,   46,   47,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  349,  350,  351,  352,   59,  354,  355,  356,  357,
  358,  359,  360,  361,   -1,   -1,   -1,   -1,   -1,   -1,
  349,  350,  351,  352,   -1,  354,  355,  356,  357,  358,
  359,  360,  361,   -1,   -1,   -1,   -1,   -1,   -1,   93,
   94,   -1,  349,  350,  351,  352,   -1,  354,  355,  356,
  357,  358,  359,  360,  361,   -1,  349,  350,  351,  352,
   -1,  354,  355,  356,  357,  358,  359,  360,  361,   -1,
   -1,   -1,  126,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   33,   -1,   35,   -1,   37,   -1,
   -1,   40,   41,   42,   43,   44,   45,   46,   47,   -1,
   -1,   37,   -1,   -1,   -1,   -1,   42,   43,   44,   45,
   59,   47,   -1,   -1,   -1,   64,   -1,   37,   -1,   -1,
   -1,   -1,   42,   43,   44,   45,   -1,   47,   -1,   37,
   -1,   -1,   -1,   -1,   42,   43,   -1,   45,   -1,   47,
   -1,   -1,   -1,   -1,   93,   37,   -1,   -1,   -1,   41,
   42,   43,   -1,   45,   -1,   47,   -1,   -1,   94,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   94,   -1,   -1,  126,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   94,   -1,   -1,  349,
  350,  351,  352,   -1,  354,  355,  356,  357,  358,  359,
  360,  361,   94,  257,  258,  259,   -1,  349,  350,  351,
  352,   -1,  354,  355,  356,  357,  358,  359,  360,  361,
  274,  275,  276,  277,   -1,   -1,   -1,   -1,   -1,   -1,
   33,   -1,   35,   -1,   37,   -1,  290,   40,   41,   42,
   43,   44,   45,   46,   47,  299,  300,  301,   -1,   -1,
   -1,  305,  306,  307,  308,  309,   59,  311,  312,  313,
   -1,   64,   -1,   -1,  318,  319,  320,  321,   -1,  323,
   -1,   -1,   -1,   -1,  328,  329,   -1,   -1,  332,  333,
   -1,   -1,   -1,   -1,  338,  339,  340,   -1,   -1,  343,
   93,  345,   -1,   -1,   -1,  349,  350,  351,  352,   -1,
  354,  355,  356,  357,  358,  359,  360,  361,  257,  258,
  259,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  126,   -1,  274,  275,  276,  277,   -1,
   -1,   -1,   -1,   -1,   -1,   33,   -1,   35,   -1,   37,
   -1,  290,   40,   41,   42,   43,   44,   45,   46,   47,
  299,  300,  301,   -1,   -1,   -1,  305,  306,  307,  308,
  309,   59,  311,  312,  313,   -1,   64,   -1,   -1,  318,
  319,  320,  321,   -1,  323,   -1,   -1,   -1,   -1,  328,
  329,   -1,   -1,  332,  333,   -1,   -1,   -1,   -1,  338,
  339,  340,   -1,   -1,  343,   93,  345,   -1,   -1,   -1,
  349,  350,  351,  352,   -1,  354,  355,  356,  357,  358,
  359,  360,  361,  349,  350,  351,  352,   -1,  354,  355,
  356,  357,  358,  359,  360,  361,   -1,   -1,  126,  349,
  350,  351,  352,   -1,  354,  355,  356,  357,  358,  359,
  360,  361,  350,  351,  352,   -1,  354,  355,  356,  357,
  358,  359,  360,  361,  257,  258,  259,  349,  350,  351,
  352,   -1,  354,  355,  356,  357,  358,  359,  360,  361,
   -1,  274,  275,  276,  277,   -1,   -1,   -1,   -1,   -1,
   -1,   33,   -1,   35,   -1,   37,   -1,  290,   40,   41,
   42,   43,   44,   45,   46,   47,  299,  300,  301,   -1,
   -1,   -1,  305,  306,  307,  308,  309,   59,  311,  312,
  313,   -1,   64,   -1,   -1,  318,  319,  320,  321,   -1,
  323,   -1,   -1,   -1,   -1,  328,  329,   -1,   -1,  332,
  333,   -1,   -1,   -1,   -1,  338,  339,  340,   -1,   -1,
  343,   93,  345,   -1,   -1,   -1,  349,  350,  351,  352,
   -1,  354,  355,  356,  357,  358,  359,  360,  361,  257,
  258,  259,   37,   -1,   -1,   -1,   41,   42,   43,   -1,
   45,   -1,   47,   -1,  126,   -1,  274,  275,  276,  277,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  290,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  299,  300,  301,   -1,   -1,   -1,  305,  306,  307,
  308,  309,   -1,  311,  312,  313,   -1,   -1,   -1,   94,
  318,  319,  320,  321,   -1,  323,   -1,   -1,   -1,   -1,
  328,  329,   -1,   -1,  332,  333,   -1,   -1,   -1,   -1,
  338,  339,  340,   -1,   -1,  343,   -1,  345,   -1,   -1,
   -1,  349,  350,  351,  352,   -1,  354,  355,  356,  357,
  358,  359,  360,  361,   -1,   -1,   -1,   -1,   -1,   33,
   -1,   35,   -1,   37,   -1,   -1,   -1,   41,   42,   43,
   44,   45,   -1,   47,   -1,   -1,   37,   -1,   -1,   -1,
   -1,   42,   43,   44,   45,   59,   47,   -1,   -1,   -1,
   64,   -1,   -1,   -1,   -1,  257,  258,  259,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  274,  275,  276,  277,   37,   -1,   -1,   93,
   94,   42,   43,   -1,   45,   -1,   47,   -1,  290,   -1,
   -1,   -1,   -1,   94,   -1,   -1,   -1,  299,  300,  301,
   -1,   -1,   -1,  305,  306,  307,  308,  309,   -1,  311,
  312,  313,  126,   -1,   -1,   -1,  318,  319,  320,  321,
   -1,  323,   -1,   -1,   -1,   -1,  328,  329,   -1,   -1,
  332,  333,   -1,   94,   -1,   -1,  338,  339,  340,   -1,
   -1,  343,   -1,  345,   -1,   -1,   -1,  349,  350,  351,
  352,   -1,  354,  355,  356,  357,  358,  359,  360,  361,
   33,   -1,   35,   -1,   -1,   -1,   -1,   40,   41,   -1,
   43,   44,   45,   46,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   59,   -1,   -1,   -1,
   -1,   64,  280,  281,  282,  283,  284,  285,  286,  287,
  288,  289,   -1,  291,  292,  293,  294,  295,  296,   -1,
   -1,   37,   -1,   -1,  302,  303,   42,   43,   44,   45,
   93,   47,   -1,   -1,  349,  350,  351,  352,   -1,  354,
  355,  356,  357,  358,  359,  360,  361,   -1,   -1,   -1,
   -1,   -1,   -1,  257,  258,  259,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  126,   -1,   -1,   -1,   -1,   -1,   -1,
  274,  275,  276,  277,   -1,   -1,   -1,   -1,   94,   -1,
   33,   -1,   35,   -1,   -1,   -1,  290,   40,   41,   -1,
   43,   44,   45,   46,   -1,  299,  300,  301,   -1,   -1,
   -1,  305,  306,  307,  308,  309,   59,  311,  312,  313,
   -1,   64,   -1,   -1,  318,  319,  320,  321,   -1,  323,
   -1,   -1,   -1,   -1,  328,  329,   -1,   -1,  332,  333,
   -1,   -1,   -1,   -1,  338,  339,  340,   -1,   -1,  343,
   93,  345,   -1,   -1,   -1,  349,  350,  351,  352,   -1,
  354,  355,  356,  357,  358,  359,  360,  361,  349,  350,
  351,  352,   -1,  354,  355,  356,  357,  358,  359,  360,
  361,   -1,   -1,  126,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   33,   -1,   35,  257,  258,  259,   -1,   40,   41,
   -1,   -1,   44,   -1,   46,  356,  357,  358,  359,  360,
  361,  274,  275,  276,  277,   -1,   -1,   59,   -1,   -1,
   -1,   -1,   64,   -1,   -1,   -1,   -1,  290,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  299,  300,  301,   -1,
   -1,   -1,  305,  306,  307,  308,  309,   -1,  311,  312,
  313,   93,   -1,   -1,   -1,  318,  319,  320,  321,   -1,
  323,   -1,   -1,   -1,   -1,  328,  329,   -1,   -1,  332,
  333,   -1,   -1,   -1,   -1,  338,  339,  340,   -1,   -1,
  343,   -1,  345,   -1,  126,   -1,  349,  350,  351,  352,
   -1,  354,  355,  356,  357,  358,  359,  360,  361,   -1,
   -1,   33,   -1,   35,  257,  258,  259,   -1,   40,   41,
   -1,   -1,   44,   -1,   46,   -1,   -1,   -1,   -1,   -1,
   -1,  274,  275,  276,  277,   -1,   -1,   59,   -1,   -1,
   -1,   -1,   64,  349,  350,  351,  352,  290,  354,  355,
  356,  357,  358,  359,  360,  361,  299,  300,  301,   -1,
   -1,   -1,  305,  306,  307,  308,  309,   -1,  311,  312,
  313,   93,   -1,   -1,   -1,  318,  319,  320,  321,   -1,
  323,   -1,   -1,   -1,   -1,  328,  329,   -1,   -1,  332,
  333,   -1,   -1,   -1,   -1,  338,  339,  340,   -1,   -1,
  343,   -1,  345,   -1,  126,   -1,  349,  350,  351,  352,
   -1,  354,  355,  356,  357,  358,  359,  360,  361,   -1,
   -1,   -1,   33,   -1,   35,  257,  258,  259,   -1,   40,
   41,   -1,   -1,   44,   -1,   46,   -1,   -1,   -1,   -1,
   -1,   -1,  274,  275,  276,  277,   -1,   -1,   59,   -1,
   -1,   -1,   -1,   64,   -1,   -1,   -1,   -1,  290,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  299,  300,  301,
   -1,   -1,   -1,  305,  306,  307,  308,  309,   -1,  311,
  312,  313,   93,   -1,   -1,   -1,  318,  319,  320,  321,
   -1,  323,   -1,   -1,   -1,   -1,  328,  329,   -1,   -1,
  332,  333,   -1,   -1,   -1,   -1,  338,  339,  340,   -1,
   -1,  343,   -1,  345,   -1,  126,   -1,  349,  350,  351,
  352,   -1,  354,  355,  356,  357,  358,  359,  360,  361,
   -1,   -1,   33,   -1,   35,  257,  258,  259,   -1,   40,
   41,   -1,   -1,   44,   -1,   46,   -1,   -1,   -1,   -1,
   -1,   -1,  274,  275,  276,  277,   -1,   -1,   59,   -1,
   -1,   -1,   -1,   64,   -1,   -1,   -1,   -1,  290,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  299,  300,  301,
   -1,   -1,   -1,  305,  306,  307,  308,  309,   -1,  311,
  312,  313,   93,   -1,   -1,   -1,  318,  319,  320,  321,
   -1,  323,   -1,   -1,   -1,   -1,  328,  329,   -1,   -1,
  332,  333,   -1,   -1,   -1,   -1,  338,  339,  340,   -1,
   -1,  343,   -1,  345,   -1,  126,   -1,  349,  350,  351,
  352,   -1,  354,  355,  356,  357,  358,  359,  360,  361,
   -1,   -1,   -1,   33,   -1,   35,  257,  258,  259,   -1,
   40,   41,   -1,   -1,   44,   -1,   46,   -1,   -1,   -1,
   -1,   -1,   -1,  274,  275,  276,  277,   -1,   -1,   59,
   -1,   -1,   -1,   -1,   64,   -1,   -1,   -1,   -1,  290,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  299,  300,
  301,   -1,   -1,   -1,  305,  306,  307,  308,  309,   -1,
  311,  312,  313,   93,   -1,   -1,   -1,  318,  319,  320,
  321,   -1,  323,   -1,   -1,   -1,   -1,  328,  329,   -1,
   -1,  332,  333,   -1,   -1,   -1,   -1,  338,  339,  340,
   -1,   -1,  343,   -1,  345,   -1,  126,   -1,  349,  350,
  351,  352,   -1,  354,  355,  356,  357,  358,  359,   -1,
   -1,   -1,   -1,   33,   -1,   35,  257,  258,  259,   -1,
   40,   41,   -1,   -1,   44,   -1,   46,   -1,   -1,   -1,
   -1,   -1,   -1,  274,  275,  276,  277,   37,   -1,   59,
   -1,   41,   42,   43,   64,   45,   -1,   47,   -1,  290,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  299,  300,
  301,   -1,   -1,   -1,  305,  306,  307,  308,  309,   -1,
  311,  312,  313,   93,   -1,   -1,   -1,  318,  319,  320,
  321,   -1,  323,   -1,   -1,   -1,   -1,  328,  329,   -1,
   -1,  332,  333,   -1,   94,   -1,   -1,  338,  339,  340,
   -1,   -1,  343,   -1,  345,   -1,  126,   -1,  349,  350,
  351,  352,   -1,  354,  355,  356,  357,  358,  359,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,  258,  259,
   37,   -1,   -1,   -1,   -1,   42,   43,   44,   45,   -1,
   47,   -1,   -1,   37,  274,  275,  276,  277,   42,   43,
   44,   45,   -1,   47,   -1,   -1,   -1,   37,   -1,   -1,
  290,   41,   42,   43,   -1,   45,   -1,   47,   -1,  299,
  300,  301,   -1,   -1,   -1,  305,  306,  307,  308,  309,
   -1,  311,  312,  313,   -1,   -1,   -1,   94,  318,  319,
  320,  321,   -1,  323,   -1,   -1,   -1,   -1,  328,  329,
   94,   -1,  332,  333,   -1,   -1,   -1,   -1,  338,  339,
  340,   -1,   -1,  343,   94,  345,   -1,   -1,   -1,  349,
  350,  351,  352,   -1,  354,  355,  356,  357,  358,  359,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,  258,  259,
   37,   -1,   -1,   -1,   41,   42,   43,   -1,   45,   -1,
   47,   -1,   -1,   37,  274,  275,  276,  277,   42,   43,
   44,   45,   -1,   47,   -1,   -1,   -1,   37,   -1,   -1,
  290,   41,   42,   43,   -1,   45,   -1,   47,   -1,  299,
  300,  301,   -1,   -1,   -1,  305,  306,  307,  308,  309,
   -1,  311,  312,  313,   -1,   -1,   -1,   94,  318,  319,
  320,  321,   -1,  323,   -1,   -1,   -1,   -1,  328,  329,
   94,   -1,  332,  333,   -1,   -1,   -1,   -1,  338,  339,
  340,   -1,   -1,  343,   94,  345,   -1,   -1,   -1,  349,
  350,  351,  352,   -1,  354,  355,  356,  357,  358,  359,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  349,
  350,  351,  352,   -1,  354,  355,  356,  357,  358,  359,
  360,  361,   37,   -1,   -1,   -1,   41,   42,   43,   -1,
   45,   -1,   47,   -1,   -1,   37,   -1,   -1,   -1,   41,
   42,   43,   -1,   45,   -1,   47,   -1,   -1,   -1,   37,
   -1,   -1,   -1,   -1,   42,   43,   44,   45,   -1,   47,
   -1,   -1,   37,   -1,   -1,   -1,   41,   42,   43,   -1,
   45,   -1,   47,   -1,   -1,   -1,   37,   -1,   -1,   94,
   41,   42,   43,   -1,   45,   -1,   47,   -1,   -1,   37,
   -1,   -1,   94,   41,   42,   43,   -1,   45,   -1,   47,
   -1,   -1,  349,  350,  351,  352,   94,  354,  355,  356,
  357,  358,  359,  360,  361,  349,  350,  351,  352,   94,
  354,  355,  356,  357,  358,  359,  360,  361,   -1,  349,
  350,  351,  352,   94,  354,  355,  356,  357,  358,  359,
  360,  361,   37,   -1,   -1,   -1,   94,   42,   43,   44,
   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,   -1,   37,
   -1,   -1,   -1,   41,   42,   43,   -1,   45,   -1,   47,
   -1,   -1,   37,   -1,   -1,   -1,   41,   42,   43,   -1,
   45,   -1,   47,   -1,   -1,   -1,   37,   -1,   -1,   -1,
   41,   42,   43,   -1,   45,   -1,   47,   -1,   -1,   94,
   37,   -1,   -1,   -1,   -1,   42,   43,   -1,   45,   -1,
   47,   -1,  349,  350,  351,  352,   94,  354,  355,  356,
  357,  358,  359,  360,  361,  349,  350,  351,  352,   94,
  354,  355,  356,  357,  358,  359,  360,  361,   -1,  349,
  350,  351,  352,   94,  354,  355,  356,  357,  358,  359,
  360,  361,   -1,   -1,   -1,   -1,   -1,   94,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  349,  350,  351,  352,   -1,  354,
  355,  356,  357,  358,  359,  360,  361,  349,  350,  351,
  352,   -1,  354,  355,  356,  357,  358,  359,  360,  361,
   -1,  349,  350,  351,  352,   -1,  354,  355,  356,  357,
  358,  359,  360,  361,  349,  350,  351,  352,   -1,  354,
  355,  356,  357,  358,  359,  360,  361,   -1,  349,  350,
  351,  352,   -1,  354,  355,  356,  357,  358,  359,  360,
  361,  349,  350,  351,  352,   -1,  354,  355,  356,  357,
  358,  359,  360,  361,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  349,  350,  351,  352,   -1,  354,
  355,  356,  357,  358,  359,  360,  361,   -1,   -1,   -1,
   -1,  349,  350,  351,  352,   -1,  354,  355,  356,  357,
  358,  359,  360,  361,  349,  350,  351,  352,   -1,  354,
  355,  356,  357,  358,  359,  360,  361,   -1,  349,  350,
  351,  352,   -1,  354,  355,  356,  357,  358,  359,  360,
  361,   -1,  349,  350,  351,  352,   -1,  354,  355,  356,
  357,  358,  359,  360,  361,   33,   -1,   35,   -1,   -1,
   -1,   -1,   40,   41,   -1,   -1,   44,   -1,   46,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   59,   -1,   -1,   -1,   -1,   64,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   93,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   33,   -1,   35,   -1,  126,   -1,
   -1,   40,   41,   -1,   -1,   44,   -1,   46,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   59,   -1,   -1,   -1,   -1,   64,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   93,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   33,   -1,   35,   -1,  126,   -1,   -1,
   40,   41,   -1,   -1,   44,   -1,   46,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   59,
   -1,   -1,   -1,   -1,   64,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,
  258,  259,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   93,   -1,   -1,  274,  275,  276,  277,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  290,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  299,  300,  301,   -1,   -1,  126,  305,  306,  307,
  308,  309,   -1,  311,  312,  313,   -1,   -1,   -1,   -1,
  318,  319,  320,  321,   -1,  323,   -1,   -1,   -1,   -1,
  328,  329,   -1,   -1,  332,  333,   -1,   -1,   -1,   -1,
  338,  339,  340,   -1,   -1,  343,   -1,  345,  257,  258,
  259,  349,  350,  351,  352,   -1,  354,  355,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  274,  275,  276,  277,   -1,
   -1,   -1,   -1,   -1,   -1,   33,   -1,   35,   -1,   -1,
   -1,  290,   40,   41,   -1,   -1,   44,   -1,   46,   -1,
  299,  300,  301,   -1,   -1,   -1,  305,  306,  307,  308,
  309,   59,  311,  312,  313,   -1,   64,   -1,   -1,  318,
  319,  320,  321,   -1,  323,   -1,   -1,   -1,   -1,  328,
  329,   -1,   -1,  332,  333,   -1,   -1,   -1,   -1,  338,
  339,  340,   -1,   -1,  343,   93,  345,  257,  258,  259,
  349,  350,  351,  352,   -1,  354,  355,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  274,  275,  276,  277,   -1,   -1,
   -1,   -1,   -1,   -1,   33,   -1,   35,   -1,  126,   -1,
  290,   40,   41,   -1,   -1,   44,   -1,   46,   -1,  299,
  300,  301,   -1,   -1,   -1,  305,  306,  307,  308,  309,
   59,  311,  312,  313,   -1,   64,   -1,   -1,  318,  319,
  320,  321,   -1,  323,   -1,   -1,   -1,   -1,  328,  329,
   -1,   -1,  332,  333,   -1,   -1,   -1,   -1,  338,  339,
  340,   -1,   -1,  343,   93,  345,   -1,   -1,   -1,  349,
  350,  351,  352,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   33,   -1,   35,   -1,   -1,   -1,   -1,   40,
   41,   -1,   -1,   44,   -1,   46,   -1,  126,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   59,   -1,
   -1,   -1,   -1,   64,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,
  258,  259,   93,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  274,  275,  276,  277,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  290,   -1,   -1,  126,   -1,   -1,   -1,   -1,
   -1,  299,  300,  301,   -1,   -1,   -1,  305,  306,  307,
  308,  309,   -1,  311,  312,  313,   -1,   -1,   -1,   -1,
  318,  319,  320,  321,   -1,  323,   -1,   -1,   -1,   -1,
  328,  329,   -1,   -1,  332,  333,   -1,   -1,   -1,   -1,
  338,  339,  340,   -1,   -1,  343,   -1,  345,  257,  258,
  259,  349,  350,  351,  352,   -1,   -1,   33,   -1,   35,
   -1,   -1,   -1,   -1,   40,  274,  275,  276,  277,   45,
   46,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  290,   -1,   -1,   -1,   -1,   -1,   -1,   64,   -1,
  299,  300,  301,   -1,   -1,   -1,  305,  306,  307,  308,
  309,   -1,  311,  312,  313,   -1,   -1,   -1,   -1,  318,
  319,  320,  321,   -1,  323,   -1,   -1,   -1,   94,  328,
  329,   -1,   -1,  332,  333,   -1,  257,  258,  259,  338,
  339,  340,   -1,   -1,  343,   -1,  345,   -1,   -1,   -1,
  349,  350,   -1,  274,  275,  276,  277,   -1,   -1,   -1,
  126,   -1,   -1,   -1,   33,   -1,   35,   -1,   -1,  290,
   -1,   40,   -1,   42,   -1,   -1,   45,   46,  299,  300,
  301,   -1,   -1,   -1,  305,  306,  307,  308,  309,   -1,
  311,  312,  313,   -1,   -1,   64,   -1,  318,  319,  320,
  321,   -1,  323,   -1,   -1,   -1,   -1,  328,  329,   -1,
   -1,  332,  333,   -1,   -1,   -1,   -1,  338,  339,  340,
   -1,   -1,  343,   -1,  345,   94,   -1,   -1,  349,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   33,  126,   35,   -1,
   -1,   -1,   -1,   40,   -1,   -1,   -1,   -1,   45,   46,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   64,   -1,   -1,
   -1,  257,  258,  259,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  274,  275,
  276,  277,   -1,   -1,   -1,   -1,   -1,   94,   -1,   -1,
   -1,   -1,   -1,   -1,  290,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  299,  300,  301,   -1,   -1,  304,  305,
  306,  307,  308,  309,   -1,  311,  312,  313,   -1,  126,
   -1,   -1,  318,  319,  320,  321,   -1,  323,   -1,   -1,
   -1,   -1,  328,  329,   -1,   -1,  332,  333,   33,   -1,
   35,   -1,  338,  339,  340,   40,   -1,  343,   -1,  345,
   -1,   46,   -1,   -1,   -1,   -1,   -1,   -1,  257,  258,
  259,   -1,   -1,   -1,   59,   -1,   -1,   -1,   -1,   64,
   -1,   -1,   -1,   -1,   -1,  274,  275,  276,  277,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  290,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  299,  300,  301,   -1,   -1,   -1,  305,  306,  307,  308,
  309,   -1,  311,  312,  313,   -1,   -1,   -1,   -1,  318,
  319,  320,  321,   -1,  323,   -1,   -1,   -1,   -1,  328,
  329,  126,   -1,  332,  333,   33,   -1,   35,   -1,  338,
  339,  340,   40,   -1,  343,   -1,  345,   -1,   46,   -1,
  257,  258,  259,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   59,   -1,   -1,   -1,   -1,   64,  274,  275,  276,
  277,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  290,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  299,  300,  301,   -1,   -1,   -1,  305,  306,
  307,  308,  309,   -1,  311,  312,  313,   -1,   -1,   -1,
   -1,  318,  319,  320,  321,   -1,  323,   -1,   -1,   -1,
   -1,  328,  329,   -1,   -1,  332,  333,   -1,  126,   -1,
   -1,  338,  339,  340,   -1,   -1,  343,   -1,  345,   -1,
   46,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  257,  258,  259,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  274,
  275,  276,  277,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  290,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  299,  300,  301,   -1,   -1,   -1,
  305,  306,  307,  308,  309,   -1,  311,  312,  313,  125,
   -1,   -1,   -1,  318,  319,  320,  321,   46,  323,   -1,
   -1,   -1,   -1,  328,  329,   -1,   -1,  332,  333,   -1,
   -1,   -1,   -1,  338,  339,  340,   -1,   -1,  343,   -1,
  345,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,
  258,  259,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  274,  275,  276,  277,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  290,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  299,  300,  301,   -1,   -1,   -1,  305,  306,  307,
  308,  309,   -1,  311,  312,  313,   -1,   -1,   -1,   -1,
  318,  319,  320,  321,   -1,  323,   -1,   -1,   -1,   -1,
  328,  329,   -1,   -1,  332,  333,   -1,   -1,   -1,   -1,
  338,  339,  340,   -1,   -1,  343,   -1,  345,   -1,   -1,
   -1,   -1,   -1,  259,  260,   -1,   -1,  263,  264,   -1,
  266,   -1,   -1,  269,  270,  271,  272,  273,   -1,   -1,
   -1,   -1,  278,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  297,  298,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  310,   -1,   -1,   -1,  314,  315,
  316,  317,   -1,   -1,   -1,   -1,  322,   -1,  324,  325,
  326,  327,   -1,   -1,  330,  331,   -1,   -1,  334,  335,
  336,  337,   -1,   -1,   -1,  341,  342,   -1,  344,   -1,
  259,  260,   -1,   -1,  263,  264,   -1,  266,   -1,   -1,
  269,  270,  271,  272,  273,   -1,   -1,   -1,   -1,  278,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  297,  298,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  310,   -1,   -1,   -1,  314,  315,  316,  317,   -1,
   -1,   -1,   -1,  322,   -1,  324,  325,  326,  327,   -1,
   -1,  330,  331,   -1,   -1,  334,  335,  336,  337,   -1,
   -1,   -1,  341,  342,   -1,  344,
};
#if YYBTYACC
static const YYINT xxctable[] = {                        -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,
};
#endif
#define YYFINAL 2
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 366
#define YYUNDFTOKEN 389
#define YYTRANSLATE(a) ((a) > YYMAXTOKEN ? YYUNDFTOKEN : (a))
#if YYDEBUG
static const char *const xxname[] = {

"$end",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'!'",0,
"'#'",0,"'%'",0,0,"'('","')'","'*'","'+'","','","'-'","'.'","'/'",0,0,0,0,0,0,0,
0,0,0,"':'","';'",0,"'='",0,0,"'@'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,"'['",0,"']'","'^'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,"'{'",0,"'}'","'~'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"error","NR","STRING","NAME","IF",
"IF2","ELSE","WHILE","FOR","IN","PRINT","ARG","SKIP","GOTO","BREAK","CONTINUE",
"STOP","NEXT_T","BEGIN","END","SIZE","RETRIEVE","FUNCTION","CALL","ROUND",
"BRACKET","CURLY","LEN","MARK","SEQ","LNR","RANGE","FNM","FCT","ITOSTR","BOUND",
"MBND_D","MBND_R","NXT","PRV","JMP","UNSET","RETURN","RE_MATCH","FIRST_T",
"LAST_T","TXT","TYP","NEWTOK","SUBSTR","SPLIT","STRLEN","STRCHR","STRRCHR",
"SET_RANGES","CPU","N_CORE","SUM","A_UNIFY","LOCK","UNLOCK","ASSERT","TERSE",
"TRUE","FALSE","VERBOSE","FCTS","MARKS","SAVE","RESTORE","RESET","SRC_LN",
"HASH","HASHARRAY","ADD_PATTERN","DEL_PATTERN","IS_PATTERN","CP_PSET","ADD_TOP",
"ADD_BOT","POP_TOP","POP_BOT","TOP","BOT","OBTAIN_EL","RELEASE_EL","UNLIST",
"LLENGTH","GLOBAL","DISAMBIGUATE","PART","DEF","PACKAGE","OR","AND","B_OR",
"B_AND","B_XOR","EQ","NE","GT","LT","GE","LE","LSH","RSH","UMIN","INCR","DECR",
"REDEF","GUNNY","$accept","all","c_prog","prog","stmnt","expr","optelse",
"params","b_stmnt","p_lhs","glob_list","args","e_list","actuals","nr_or_cpu",
"s_ref","t_ref","p_ref","par_list","glob_nm","b_name","fld","illegal-symbol",
};
static const char *const xxrule[] = {
"$accept : all",
"all : c_prog",
"c_prog : '{' prog '}'",
"prog : stmnt",
"prog : stmnt prog",
"stmnt : IF '(' expr ')' c_prog optelse",
"stmnt : WHILE '(' expr ')' c_prog",
"stmnt : FOR '(' NAME IN NAME ')' c_prog",
"stmnt : FUNCTION NAME '(' params ')' c_prog",
"stmnt : NAME ':' stmnt",
"stmnt : b_stmnt ';'",
"b_stmnt : p_lhs '=' expr",
"b_stmnt : p_lhs '=' NEWTOK '(' ')'",
"b_stmnt : ASSERT '(' expr ')'",
"b_stmnt : SRC_LN '(' expr ',' expr ',' expr ')'",
"b_stmnt : GLOBAL glob_list",
"b_stmnt : GOTO NAME",
"b_stmnt : PRINT args",
"b_stmnt : UNSET NAME '[' e_list ']'",
"b_stmnt : UNSET NAME",
"b_stmnt : FCTS '(' ')'",
"b_stmnt : RESET '(' ')'",
"b_stmnt : SAVE '(' expr ',' expr ')'",
"b_stmnt : RESTORE '(' expr ',' expr ')'",
"b_stmnt : LOCK '(' ')'",
"b_stmnt : UNLOCK '(' ')'",
"b_stmnt : NAME '(' actuals ')'",
"b_stmnt : p_lhs INCR",
"b_stmnt : p_lhs DECR",
"b_stmnt : SET_RANGES '(' expr ',' expr ')'",
"b_stmnt : A_UNIFY '(' NAME ',' nr_or_cpu ')'",
"b_stmnt : A_UNIFY '(' nr_or_cpu ')'",
"b_stmnt : ADD_PATTERN '(' s_ref ',' t_ref ',' t_ref ')'",
"b_stmnt : DEL_PATTERN '(' s_ref ',' t_ref ',' t_ref ')'",
"b_stmnt : RELEASE_EL '(' expr ')'",
"b_stmnt : POP_TOP '(' NAME ')'",
"b_stmnt : POP_BOT '(' NAME ')'",
"b_stmnt : UNLIST '(' NAME ')'",
"b_stmnt : ADD_TOP '(' NAME ',' expr ')'",
"b_stmnt : ADD_BOT '(' NAME ',' expr ')'",
"b_stmnt : RETURN expr",
"b_stmnt : RETURN",
"b_stmnt : BREAK",
"b_stmnt : CONTINUE",
"b_stmnt : NEXT_T",
"b_stmnt : STOP",
"t_ref : NAME",
"t_ref : p_ref",
"t_ref : '.'",
"nr_or_cpu : NR",
"nr_or_cpu : CPU",
"params :",
"params : par_list",
"actuals :",
"actuals : e_list",
"glob_nm : NAME",
"glob_nm : NAME '[' ']'",
"glob_list : glob_nm",
"glob_list : glob_list ',' glob_nm",
"par_list : NAME",
"par_list : params ',' NAME",
"optelse :",
"optelse : ELSE c_prog",
"args : expr",
"args : args expr",
"b_name : NAME",
"b_name : NAME '[' e_list ']'",
"expr : '(' expr ')'",
"expr : expr GT expr",
"expr : expr GE expr",
"expr : expr LT expr",
"expr : expr LE expr",
"expr : expr EQ expr",
"expr : expr NE expr",
"expr : expr OR expr",
"expr : expr AND expr",
"expr : expr '+' expr",
"expr : expr '-' expr",
"expr : expr '*' expr",
"expr : expr '/' expr",
"expr : expr '%' expr",
"expr : expr B_OR expr",
"expr : expr B_AND expr",
"expr : expr '^' expr",
"expr : expr LSH expr",
"expr : expr RSH expr",
"expr : '!' expr",
"expr : '-' expr",
"expr : '~' expr",
"expr : '^' expr",
"expr : STRING",
"expr : CP_PSET '(' s_ref ')'",
"expr : HASH '(' expr ')'",
"expr : HASHARRAY '(' expr ',' expr ')'",
"expr : IS_PATTERN '(' s_ref ')'",
"expr : SUBSTR '(' expr ',' expr ',' expr ')'",
"expr : SPLIT '(' expr ',' NAME ')'",
"expr : SPLIT '(' expr ',' STRING ',' NAME ')'",
"expr : STRCHR '(' expr ',' STRING ')'",
"expr : STRRCHR '(' expr ',' STRING ')'",
"expr : LLENGTH '(' NAME ')'",
"expr : TOP '(' NAME ')'",
"expr : BOT '(' NAME ')'",
"expr : OBTAIN_EL '(' ')'",
"expr : MARKS '(' expr ')'",
"expr : STRLEN '(' expr ')'",
"expr : SIZE '(' NAME ')'",
"expr : SUM '(' p_lhs ')'",
"expr : RETRIEVE '(' NAME ',' expr ')'",
"expr : RE_MATCH '(' p_lhs ',' STRING ')'",
"expr : RE_MATCH '(' STRING ')'",
"expr : ITOSTR '(' expr ')'",
"expr : DISAMBIGUATE '(' NAME ')'",
"expr : NAME '(' actuals ')'",
"expr : '@' NAME",
"expr : '@' TYP",
"expr : '#' NAME",
"expr : b_name '@' expr",
"expr : p_ref '.' fld",
"expr : p_ref",
"expr : p_lhs",
"expr : CPU",
"expr : TERSE",
"expr : VERBOSE",
"expr : N_CORE",
"expr : NR",
"expr : TRUE",
"expr : FALSE",
"s_ref : expr",
"s_ref : '*'",
"p_ref : BEGIN",
"p_ref : END",
"p_ref : FIRST_T",
"p_ref : LAST_T",
"p_lhs : NAME '.' fld",
"p_lhs : '.' fld",
"p_lhs : b_name",
"p_lhs : '.'",
"e_list : expr",
"e_list : e_list ',' expr",
"fld : BOUND",
"fld : MBND_D",
"fld : MBND_R",
"fld : BRACKET",
"fld : CURLY",
"fld : FCT",
"fld : FNM",
"fld : JMP",
"fld : LEN",
"fld : LNR",
"fld : MARK",
"fld : NXT",
"fld : PRV",
"fld : RANGE",
"fld : ROUND",
"fld : SEQ",
"fld : TXT",
"fld : TYP",

};
#endif

#if YYDEBUG
int      yydebug;
#endif

int      yyerrflag;
int      yychar;
YYSTYPE  yyval;
YYSTYPE  yylval;
int      yynerrs;

#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
YYLTYPE  yyloc; /* position returned by actions */
YYLTYPE  yylloc; /* position from the lexer */
#endif

#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
#ifndef YYLLOC_DEFAULT
#define YYLLOC_DEFAULT(loc, rhs, n) \
do \
{ \
    if (n == 0) \
    { \
        (loc).first_line   = YYRHSLOC(rhs, 0).last_line; \
        (loc).first_column = YYRHSLOC(rhs, 0).last_column; \
        (loc).last_line    = YYRHSLOC(rhs, 0).last_line; \
        (loc).last_column  = YYRHSLOC(rhs, 0).last_column; \
    } \
    else \
    { \
        (loc).first_line   = YYRHSLOC(rhs, 1).first_line; \
        (loc).first_column = YYRHSLOC(rhs, 1).first_column; \
        (loc).last_line    = YYRHSLOC(rhs, n).last_line; \
        (loc).last_column  = YYRHSLOC(rhs, n).last_column; \
    } \
} while (0)
#endif /* YYLLOC_DEFAULT */
#endif /* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */
#if YYBTYACC

#ifndef YYLVQUEUEGROWTH
#define YYLVQUEUEGROWTH 32
#endif
#endif /* YYBTYACC */

/* define the initial stack-sizes */
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH  YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 10000
#define YYMAXDEPTH  10000
#endif
#endif

#ifndef YYINITSTACKSIZE
#define YYINITSTACKSIZE 200
#endif

typedef struct {
    unsigned stacksize;
    YYINT    *s_base;
    YYINT    *s_mark;
    YYINT    *s_last;
    YYSTYPE  *l_base;
    YYSTYPE  *l_mark;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
    YYLTYPE  *p_base;
    YYLTYPE  *p_mark;
#endif
} YYSTACKDATA;
#if YYBTYACC

struct YYParseState_s
{
    struct YYParseState_s *save;    /* Previously saved parser state */
    YYSTACKDATA            yystack; /* saved parser stack */
    int                    state;   /* saved parser state */
    int                    errflag; /* saved error recovery status */
    int                    lexeme;  /* saved index of the conflict lexeme in the lexical queue */
    YYINT                  ctry;    /* saved index in yyctable[] for this conflict */
};
typedef struct YYParseState_s YYParseState;
#endif /* YYBTYACC */
/* variables for the parser stack */
static YYSTACKDATA yystack;
#if YYBTYACC

/* Current parser state */
static YYParseState *yyps = 0;

/* yypath != NULL: do the full parse, starting at *yypath parser state. */
static YYParseState *yypath = 0;

/* Base of the lexical value queue */
static YYSTYPE *yylvals = 0;

/* Current position at lexical value queue */
static YYSTYPE *yylvp = 0;

/* End position of lexical value queue */
static YYSTYPE *yylve = 0;

/* The last allocated position at the lexical value queue */
static YYSTYPE *yylvlim = 0;

#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
/* Base of the lexical position queue */
static YYLTYPE *yylpsns = 0;

/* Current position at lexical position queue */
static YYLTYPE *yylpp = 0;

/* End position of lexical position queue */
static YYLTYPE *yylpe = 0;

/* The last allocated position at the lexical position queue */
static YYLTYPE *yylplim = 0;
#endif

/* Current position at lexical token queue */
static YYINT  *yylexp = 0;

static YYINT  *yylexemes = 0;
#endif /* YYBTYACC */
#line 414 "cobra_prog.y"
static FILE *pfd;

static struct Keywords {
	char *s; int t;
} key[] = {
	{ "a_unify",	A_UNIFY },
	{ "add_pattern", ADD_PATTERN },
	{ "assert",	ASSERT },
	{ "Begin",	BEGIN },
	{ "bound",	BOUND },
	{ "bracket",	BRACKET },
	{ "break",	BREAK },
	{ "continue",	CONTINUE },
	{ "core",	CPU },
	{ "cpu",	CPU },
	{ "curly",	CURLY },
	{ "del_pattern", DEL_PATTERN },
	{ "disambiguate", DISAMBIGUATE },
	{ "else",	ELSE },
	{ "End",	END },
	{ "false",	FALSE },
	{ "fct",	FCT },
	{ "fcts",	FCTS },
	{ "first_t",	FIRST_T },
	{ "fnm",	FNM },
	{ "for",	FOR },
	{ "function",	FUNCTION },
	{ "global",	GLOBAL },
	{ "goto",	GOTO },
	{ "hash",	HASH },
	{ "hasharray",	HASHARRAY },
	{ "if",		IF },
	{ "in",		IN },
	{ "is_pattern",	IS_PATTERN },
	{ "itostr",	ITOSTR },
	{ "jmp",	JMP },
	{ "last_t",	LAST_T },
	{ "len",	LEN },
	{ "list_add_top", ADD_TOP },	{ "list_push",    ADD_TOP },
	{ "list_add_bot", ADD_BOT },	{ "list_append",  ADD_BOT },
	{ "list_del_top", POP_TOP },	{ "list_pop",     POP_TOP },
	{ "list_del_bot", POP_BOT },	{ "list_chop",    POP_BOT },
	{ "list_get_top", TOP },	{ "list_top",         TOP },
	{ "list_get_bot", BOT },	{ "list_bot",         BOT },
	{ "list_new_tok", OBTAIN_EL },	{ "list_tok",   OBTAIN_EL },
	{ "list_rel_tok", RELEASE_EL },	{ "list_tok_rel", RELEASE_EL },
	{ "list_rel",	UNLIST },
	{ "list_len",	LLENGTH },
	{ "lnr",	LNR },
	{ "lock", 	LOCK },
	{ "marks",	MARKS },
	{ "mark",	MARK },
	{ "match",	RE_MATCH },
	{ "ncore",	N_CORE },
	{ "ncpu",	N_CORE },
	{ "newtok",	NEWTOK },
	{ "Next",	NEXT_T },
	{ "nxt",	NXT },
	{ "p_start",	JMP },
	{ "p_end",	BOUND },
	{ "p_bdef",	MBND_D },
	{ "p_bref",	MBND_R },
	{ "pattern_exists", IS_PATTERN },
	{ "print",	PRINT },
	{ "prv",	PRV },
	{ "pset",	CP_PSET },
	{ "range",	RANGE },
	{ "reset",	RESET },
	{ "restore",	RESTORE },
	{ "retrieve",	RETRIEVE },
	{ "return",	RETURN },
	{ "round",	ROUND },
	{ "save",	SAVE },
	{ "seq",	SEQ },
	{ "set_ranges",	SET_RANGES },
	{ "size",	SIZE },
	{ "split",	SPLIT },
	{ "src_ln",	SRC_LN },
	{ "Stop",	STOP },
	{ "strchr",	STRCHR },
	{ "strrchr",	STRRCHR },
	{ "strlen",	STRLEN },
	{ "substr",	SUBSTR },
	{ "sum",	SUM },
	{ "terse",	TERSE },
	{ "true",	TRUE },
	{ "txt",	TXT },
	{ "type",	TYP },
	{ "typ",	TYP },
	{ "unlock",	UNLOCK },
	{ "unset",	UNSET },
	{ "verbose",	VERBOSE },
	{ "while",	WHILE },
	{ "part", PART},
	{ "def", DEF },
	{ 0, 0 }
};

static struct Keywords ops[] = {	// for tok2txt only
	{ "&&", AND },
	{ "==", EQ },
	{ ">=", GE },
	{ ">",  GT },
	{ "<=", LE },
	{ "<",  LT },
	{ "!=", NE },
	{ "||", OR },
	{ "|",  B_OR },
	{ "&",  B_AND },
	{ "^",  B_XOR },
	{ "++", INCR },
	{ "--", DECR },
	{ ">>", RSH },
	{ "<<", LSH },
	{ "@call", CALL },		// internal use
	{ "skip", SKIP },		// internal use
	{ "arg", ARG },			// internal use
	{ ":>", REDEF }, 
	{ ":>>", GUNNY },
	{ 0, 0}
};

ulong
hash2_cum(const char *s, const int seq)	// cumulative
{	static uint64_t h = 0;
	static char t = 0;

	if (seq == 0)
	{	t = *s++;
		h = 0x88888EEFL ^ (0x88888EEFL << 31);
	} else	// add a space as separator
	{	h ^= ((h << 7) ^ (h >> (57))) + ' ';
	}
	while (*s != '\0')
	{	h ^= ((h << 7) ^ (h >> (57))) + *s++;
	}
	return ((h << 7) ^ (h >> (57))) ^ t;
}

ulong
hash3(const char *s)	// debugging version of hash2
{
	if (sizeof(ulong) == 8)
	{	uint64_t h = 0x88888EEFL ^ (0x88888EEFL << 31);
		const char t = *s++;
		while (*s != '\0')
		{
			h ^= ((h << 7) ^ (h >> (57))) + *s++;
		}
		return ((h << 7) ^ (h >> (57))) ^ t;
	} else
	{	ulong h = 0x88888EEFL;
		const char t = *s++;

		while (*s != '\0')
		{	h ^= ((h << 8) ^ (h >> (24))) + *s++;
		}
		return ((h << 7) ^ (h >> (25))) ^ t;
	}
}

ulong
hash2(const char *s)
{
	if (sizeof(ulong) == 8)
	{	uint64_t h = 0x88888EEFL ^ (0x88888EEFL << 31);
		const char t = *s++;

		while (*s != '\0')
		{	h ^= ((h << 7) ^ (h >> (57))) + *s++;
		}
		return ((h << 7) ^ (h >> (57))) ^ t;
	} else
	{	ulong h = 0x88888EEFL;
		const char t = *s++;

		while (*s != '\0')
		{	h ^= ((h << 8) ^ (h >> (24))) + *s++;
		}
		return ((h << 7) ^ (h >> (25))) ^ t;
	}
}

static Lextok *
add_return(Lextok *p)
{	Lextok *e;

	if (!p->rgt)
	{	return p;
	}
	if (p->typ == '=')
	{	e = new_lex(RETURN, 0, 0);
		return new_lex(';', p, e);
	}
	if (p->rgt->typ == ';')
	{	p->rgt = add_return(p->rgt);
	} else if (p->rgt->typ != RETURN)
	{	e = new_lex(RETURN, 0, 0);
		p->rgt = new_lex(';', p->rgt, e);
	}
	return p;
}

static Lextok *
new_lex(int tp, Lextok *lft, Lextok *rgt)
{	Lextok *p;
	p = (Lextok *) emalloc(sizeof(Lextok), 73);
	p->typ = tp;
	p->lft = lft;
	p->rgt = rgt;
	p->lnr = p_lnr;
	p->tag = p_seq++;
	return p;
}

static Lextok *
mk_for(Lextok *a, Lextok *nm, Lextok *ar, Lextok *body)
{	Lextok *mrk, *seq, *asgn1, *asgn2, *loop;
	Lextok *cond, *whl, *txt;
	Lextok *setv, *one, *incr, *zero;
	Lextok *s1, *s2, *s3, *s4, *gt;
	static int ln = 0;	// parse time only
	int ix;

	// printf("for %s in %s\n", nm->s, ar->s);
	//	 asgn ;		nm.seq = size(ar);
	// loop: whl  ;		nm.mark < nm.seq
	//	 setv ;		nm.txt = retrieve(ar, nm.mark)
	//	 incr ;		nm.mark++
	//	 body ;
	//	 goto loop

	for (ix = 0; ix < Ncore; ix++)
	{	Var_nm *vn = mk_var(nm->s, PTR, ix);		// nm
		if (vn) { vn->rtyp = PTR; } // in case its an older var
	}	// so that we can use the var to cnt in nm.mark and nm.seq

	one  = new_lex(NR, 0, 0); one->val = 1;		// 1
	zero = new_lex(NR, 0, 0); 			// 0
	mrk  = new_lex('.', nm, new_lex(MARK, 0, 0));	// nm.mark
	seq  = new_lex('.', nm, new_lex(SEQ,  0, 0));	// nm.seq
	txt  = new_lex('.', nm, new_lex(TXT,  0, 0));	// nm.txt

	asgn1 = new_lex('=', seq, new_lex(SIZE, 0, ar));	// seq = size(ar)
	asgn2 = new_lex('=', mrk, zero);			// mrk = 0

	cond = new_lex(LT,  mrk, seq);			// mrk < seq
	incr = new_lex('=', mrk, new_lex('+', mrk, one)); // mrk++
	setv = new_lex('=', txt, new_lex(RETRIEVE, mrk, ar)); // txt = retrieve(ar, mrk)

	loop = new_lex(NAME, 0, 0);
	loop->s = (char *) emalloc(8*sizeof(char), 74);
	snprintf(loop->s, 8, "_@%d_", ln++);

	gt  = new_lex(GOTO,  loop, 0);	// shouldnt be needed
	s1  = new_lex(';',   body, gt);
	s2  = new_lex(';',   incr, s1);
	s3  = new_lex(';',   setv, s2);
	whl = new_lex(WHILE, cond, s3);
	mk_lab(loop, whl);

	s4  = new_lex(';',  asgn2, whl);

	return new_lex(';',  asgn1, s4);
}

static void
mk_lab(Lextok *t, Lextok *p)
{	Var_nm *n;

	assert(p);
	for (n = lab_lst; n; n = n->nxt)
	{	if (strcmp(n->nm, t->s) == 0)
		{	if (!no_match)
			{	Lextok *op = (Lextok *) n->pm;
				if (p
				&&  op
				&&  op->lnr != p->lnr)
				{	fprintf(stderr, "line %d: warning: label '%s' redefined\n",
						p->lnr, t->s);
			}	}
			if (n->pm != (Prim *) p)
			{	n->pm = (Prim *) p;
				n->cdepth = Cdepth[0];
			}
			return;
	}	}
	n = (Var_nm *) emalloc(sizeof(Var_nm), 75);	// mk_lab
	n->nm = t->s;
	n->pm = (Prim *) p; // slight abuse of type
	n->cdepth = Cdepth[0];	// during parsing only
	n->nxt = lab_lst;
	lab_lst = n;
}

static Lextok *
find_label(char *s)
{	Var_nm *n;

	for (n = lab_lst; n; n = n->nxt)
	{	if (strcmp(n->nm, s) == 0)
		{	return (Lextok *) n->pm;
	}	}
	fprintf(stderr, "error: label '%s' undefined\n", s);
	return (Lextok *) 0;
}

static void
expect(int if_t, int then_t, int else_t)
{	int n;

	n = fgetc(pfd);
	if (n == if_t)
	{	yylval->typ = then_t;
	} else
	{	ungetc(n, pfd);
		yylval->typ = else_t;
	}
}

static void
string(void)
{	int n, i = 0;

	yylval->typ = STRING;
	yylval->s = "";
	memset(yytext, 0, MAXYYTEXT);
	while ((n = fgetc(pfd)) != '"')
	{	if (n == '\\')
		{	yytext[i++] = (char) n;
			n = fgetc(pfd);
		}
		if (n == EOF || i > 1024)
		{	yyerror("unterminated string");
			break;
		}
		yytext[i++] = (char) n;
	}
	yytext[i] = '\0';
	yylval->s = emalloc(strlen(yytext)+1, 76);
	strcpy(yylval->s, yytext);
}

static void
fixstr(Lextok *t)
{	char *s;
	assert(t->typ == STRING);
	for (s = t->s; *s != '\0'; s++)
	{	if (*s == '\\')
		{	if (*(s+1) == 't')
			{	*s++ = ' ';
				*s = '\t';
			} else if (*(s+1) == '\\')
			{	s++;
			} else if (*(s+1) == 'n')
			{	if (*(s+2) == '\0')
				{	*s++ = '\n';
					*s = '\0';
				} else
				{	*s++ = ' ';
					*s = '\n';
	}	}	}	}
}

static int
prog_lex(void)
{	int n, i;

	yylval = (Lextok *) emalloc(sizeof(Lextok), 77);
	yylval->lnr = p_lnr;
	yytext[0] = '\0';
	for (;;)
	{	n = fgetc(pfd);
		if (n == '\n')
		{	p_lnr++;
			yylval->lnr++;
		}
		if (isspace((uchar) n))
		{	continue;
		}
		if (isdigit((uchar) n))
		{	for (i = 0; isdigit((uchar) n); i++)
			{	yytext[i] = (char) n;
				n = fgetc(pfd);
			}
			ungetc(n, pfd);
			yytext[i] = '\0';
			yylval->val = atoi(yytext);
			yylval->typ = NR;
		} else if (isalpha((uchar) n))
		{	for (i = 0; isalnum((uchar) n) || n == '_'; i++)
			{	yytext[i] = (char) n;
				n = fgetc(pfd);
			}
			ungetc(n, pfd);
			yytext[i] = '\0';
			yylval->s = emalloc(strlen(yytext)+1, 78);
			strcpy(yylval->s, yytext);
			yylval->typ = NAME;
			for (i = 0; key[i].s; i++)
			{	if (strcmp(yytext, key[i].s) == 0)
				{	yylval->typ = key[i].t;
					break;
			}	}
		} else
		{	if (n == '#')
			{	n = fgetc(pfd);
				if (n == '\n' || n == '\r')
				{	p_lnr++;
					yylval->lnr++;
					continue;
				}
				if (n == '#' || isspace((uchar) n)) // comment
				{	while ((n = fgetc(pfd)) != '\n')
					{	if (n == EOF)
						{	break;
					}	}
					p_lnr++;
					yylval->lnr++;
					continue;
				}
				ungetc(n, pfd);
				yylval->typ = '#';
				break;
			}
			switch (n) {
			case '\\': yylval->typ = fgetc(pfd); break;
			case '"': string(); break;
			case '>':
				  n = fgetc(pfd);
				  switch (n) {
				  case '=': yylval->typ = GE; break;
				  case '>': yylval->typ = RSH; break;
				  default:  yylval->typ = GT; ungetc(n, pfd); break;
				  }
				  break;
			case '<':
				  n = fgetc(pfd);
				  switch (n) {
				  case '=': yylval->typ = LE; break;
				  case '<': yylval->typ = LSH; break;
				  default:  yylval->typ = LT; ungetc(n, pfd); break;
				  }
				  break;
			case '=': expect('=',  EQ,  n); break;
			case '!': expect('=',  NE,  n); break;
			case '|': expect('|',  OR,  B_OR); break;
			case '&': expect('&', AND, B_AND); break;
			case '+': expect('+', INCR, n); break;
			case '-': expect('-', DECR, n); break;
			default : yylval->typ = n; break;
		}	}
		break;
	}
	return yylval->typ;
}

static void
tok2txt(Lextok *t, FILE *x)
{	int i;
	char buf[1024], *s;

	if (!t)
	{	return;
	}

	if (x != stdout)
	{	fprintf(x, "N%d:%d: ", t->tag, t->lnr);
	}
	for (i = 0; key[i].s; i++)
	{	if (t->typ == key[i].t)
		{	fprintf(x, "%s", key[i].s);
			break;
	}	}

	if (t->typ == NAME || t->typ == STRING)
	{	strncpy(buf, t->s, sizeof(buf)-1);
		buf[sizeof(buf)-1] = '\0';
		for (s = buf; *s != '\0'; s++)
		{	if (*s == '\n')
			{	*s = ' ';
		}	}
		fprintf(x, " %s", buf);
	} else if (t->typ == NR)
	{	fprintf(x, " %d", t->val);
	} else if (t->typ == CALL)
	{	fprintf(x, "  %s()", t->lft->s);
	} else
	{	if (!key[i].s)
		{	for (i = 0; ops[i].s; i++)
			{	if (t->typ == ops[i].t)
				{	break;
			}	}
			if (ops[i].s)
			{	fprintf(x, "%s", ops[i].s);
			} else if (isprint(t->typ))
			{	if ((t->typ == '#'
				||   t->typ == '@')
				&&   t->rgt && t->rgt->s)
				{	fprintf(x, "%s", t->rgt->s);
				} else
				{	fprintf(x, "'%c'", t->typ);
				}
			} else
			{	fprintf(x, "%d", t->typ);
	}	}	}

	if (x == stdout)
	{	fprintf(x, "\n");
	}
}

static void
draw_ast(Lextok *t, FILE *x)
{
	if (!t || t->tag)
	{	return;
	}
	t->tag = p_seq++;

	fprintf(x, "n%d [label=\"", t->tag);
	tok2txt(t, x);
	fprintf(x, "\"];\n");

	if (t->lft)
	{	draw_ast(t->lft, x);
		fprintf(x, "n%d -> n%d [label=L];\n", t->tag, t->lft->tag);
	}
	if (t->rgt)
	{	draw_ast(t->rgt, x);
		fprintf(x, "n%d -> n%d [label=R];\n", t->tag, t->rgt->tag);
	}
}

static void
opt_fsm(Lextok *t)	// optimize the fsm a bit
{
	if (!t || (t->visit & 8))
	{	return;
	}
	t->visit |= 8;

	while (t->a && t->a->typ == SKIP)
	{	t->a = t->a->a;
	}

	while (t->b && t->b->typ == SKIP)
	{	t->b = t->b->a;
	}

	while (t->a && t->a->typ == ';' && !t->a->b)
	{	t->a = t->a->a;
	}

	opt_fsm(t->a);
	opt_fsm(t->b);
}

static void
draw_fsm(Lextok *t, FILE *x)
{
	if (!t || (t->visit & 4))
	{	return;
	}
	t->visit |= 4;

	if (!t->tag)
	{	t->tag = p_seq++;
	}

	fprintf(x, "n%d [label=\"", t->tag);
	tok2txt(t, x);
	fprintf(x, "\"];\n");

	if (t->typ == NEXT_T || t->typ == STOP)
	{	return;
	}
	if (t->typ == CALL)
	{	if (t->c)
		{	draw_fsm(t->c, x);
			fprintf(x, "n%d -> n%d [label=nxt];\n", t->tag, t->c->tag);
		}
		return;
	}

	if (t->a)
	{	draw_fsm(t->a, x);
		fprintf(x, "n%d -> n%d [label=nxt];\n", t->tag, t->a->tag);
	}
	if (t->b)
	{	draw_fsm(t->b, x);
		fprintf(x, "n%d -> n%d [label=else];\n", t->tag, t->b->tag);
	}
}

#if 0
static void
clr_tags(Lextok *t)
{
	if (!t || t->tag == 0)
	{	return;
	}
	t->tag = 0;
	clr_tags(t->lft);
	clr_tags(t->rgt);
}
#endif

#undef DEBUG
#ifdef DEBUG
static void
indent(int level, const char *s)
{	int i;

	for (i = 0; i < level; i++)
	{	printf(" \t");
	}
	printf("%s", s);
}

static void
dump_tree(Lextok *t, int i)
{
	if (!t || (t->visit&16))
	{	indent(i, "");
		printf("<<%p::%d>>\n", (void *) t, t?t->typ:-1);
		return;
	}
	t->visit |= 16;
	indent(i, "");

	printf("<%p> ", (void *) t);

	if (t->s) { printf("%s%s ", t->f?"fct ":"", t->s); }
	tok2txt(t, stdout);
	if (t->lft)
	{	indent(i, "L:\n");
		dump_tree(t->lft, i+1);
	}
	if (t->rgt)
	{	indent(i, "R:\n");
		dump_tree(t->rgt, i+1);
	}
	if (t->a)
	{	indent(i, "a:\n");
		dump_tree(t->a, i+1);
	}
	if (t->b)
	{	indent(i, "b:\n");
		dump_tree(t->b, i+1);
	}
	if (t->c)
	{	indent(i, "c:\n");
		dump_tree(t->c, i+1);
	}
}

#if 0
static void
clean_tree(Lextok *t)
{
	if (!t || (t->visit&64))
	{	return;
	}
	t->visit &= ~16;
	t->visit |= 64;

	if (t->lft)
	{	clean_tree(t->lft);
	}
	if (t->rgt)
	{	clean_tree(t->rgt);
	}
	if (t->a)
	{	clean_tree(t->a);
	}
	if (t->b)
	{	clean_tree(t->b);
	}
	if (t->c)
	{	clean_tree(t->c);
	}
}
#endif
#endif

static Lextok *
fix_while(Lextok *t)
{	// convert the WHILE into an IF2

	if (!t || (t->visit & 1))
	{	return t;
	}
	t->visit |= 1;
	t->lft = fix_while(t->lft);
	t->rgt = fix_while(t->rgt);

#if 0
           while                             ;d1 ';'
           /    \                           / \
        cond   body               .------>if t \
                                  |      /  \   \
                                  |   cond  f2   \
                                  |       t/  \   .
       create 5 extra nodes:      |       ;g3  .->skip e4
       returns top 1              |      / \
                                  |   body  .
                                  |         |
                                  .---------.
#endif
	if (t->typ == WHILE)
	{	Lextok *d = (Lextok *) emalloc(sizeof(Lextok), 79); // 1
		Lextok *e = (Lextok *) emalloc(sizeof(Lextok), 79); // 4
		Lextok *f = (Lextok *) emalloc(sizeof(Lextok), 79); // 2
		Lextok *g = (Lextok *) emalloc(sizeof(Lextok), 79); // 3

		d->tag = p_seq++; d->lnr = t->lnr; d->typ = ';';  // d1
		e->tag = p_seq++; e->lnr = t->lnr; e->typ = SKIP; // e4
		f->tag = p_seq++; f->lnr = t->lnr; f->typ = 0;    // f2
		g->tag = p_seq++; g->lnr = t->lnr; g->typ = ';';  // g3

		d->visit |= 1;
		e->visit |= 1;
		g->visit |= 1;

		d->lft = t;
		d->rgt = e;

		t->typ = IF2;	// keep cond on t->lft
		t->a   = g;	// replaced in mk_fsm
		// t->b   = e;	// causes problems

		g->lft = t->rgt;
		g->rgt = t;

		t->rgt = f;	// needed for mk_fsm
		f->lft = g;	// needed for mk_fsm
		// f->rgt = e;	// causes problems
		f->visit |= 1;

		return d;
	}

	if (t->typ == IF)
	{	t->a = t->rgt->lft;
		t->b = t->rgt->rgt;
	}
	return t;
}

static void
add_fct(Lextok *t)
{	Function *f;

	assert(t->lft && t->rgt);

	f = (Function *) emalloc(sizeof(Function), 80);
	f->nm	  = t->lft->lft;
	f->formal = t->lft->rgt;
	f->body	  = t->rgt;
	f->nxt	  = functions;
	functions = f;
}

static void
map_var(Prim **ref_p, const char *fnm, Lextok *name, Lextok *expr, const int ix)
{	Var_nm *n;
	Rtype tmp;

	memset(&tmp, 0, sizeof(Rtype));

	assert(name->typ == NAME);		// name of formal param
	assert(ix >= 0 && ix < Ncore);

	Cdepth[ix]--;				// evaluate param in callers context
	eval_prog(ref_p, expr, &tmp, ix);
	Cdepth[ix]++;				// restore context

	if (expr->typ == NAME && is_aname(expr->s, ix))
	{	fprintf(stderr, "error: the basename of an associative array (%s) cannot be passed as a parameter\n",
			expr->s);
		show_error(stderr, expr->lnr);
	}

	n = mk_var(name->s, tmp.rtyp, ix);

	if (n->cdepth == 0)
	{	fprintf(stderr, "error: parameter name '%s' clashes with a global variable named '%s'\n",
			n->nm, n->nm);
	}

	if (sep[ix].Verbose>1)
	{	assert(ix >= 0 && ix < Ncore);
		printf("level %d, created parameter %s of type: ",
			Cdepth[ix], name->s);
		what_type(stdout, tmp.rtyp);
		printf(": ");
	}

	switch (tmp.rtyp) {
	case VAL:
		n->v  = tmp.val;
		if (sep[ix].Verbose>1)
		{	printf("%d\n", tmp.val);
		}
		break;
	case STR:
#if 1
		n->s = tmp.s;
#else
		n->s = (char *) hmalloc(strlen(tmp.s) + 1, ix, 131);		// map_var
		strcpy(n->s, tmp.s);
#endif
		if (sep[ix].Verbose>1)
		{	printf("%s\n", tmp.s);
		}
		break;
	case PTR:
		if (tmp.ptr)
		{	n->pm = tmp.ptr;
		} else
		{	n->pm = &none;
			n->pm->seq = 0;
		}
		if (sep[ix].Verbose>1 && n->pm->fnm)
		{	printf("%s:%d\n",
				n->pm->fnm, n->pm->lnr);
		}
		break;
	default:
		fprintf(stderr, "line %d: error: unknown type for %s\n",
			name->lnr, name->s);
		break;
	}
}

static void
set_actuals(Prim **ref_p, const char *fnm, Lextok *formal, Lextok *actual, const int ix)
{	// formal -- names on right, tree on left
	// actual -- expr  on right, tree on left

	if (!formal || !actual)
	{	if (formal)
		{	fprintf(stderr, "error: %s(): missing parameter(s)\n", fnm); // allow?
		} else if (actual)
		{	fprintf(stderr, "error: %s(): too many parameters\n", fnm);
		}
		return;
	}
	// descend tree left to leafs
	if (formal->lft && actual->lft)
	{	set_actuals(ref_p, fnm, formal->lft, actual->lft, ix);
	}

	if (formal->rgt)
	{	if (actual->rgt)
		{	map_var(ref_p, fnm, formal->rgt, actual->rgt, ix);
		}
	} else // if (!actual->rgt)
	{	map_var(ref_p, fnm, formal, actual, ix);
	}
}

static void
find_fct(Lextok *t, int ix)
{	Function *f;

	// fct name in t->lft
	// actual params, if any, in t->rgt
	// link call to formals and fct body

	assert(t && t->lft && t->lft->s);

	for (f = functions; f; f = f->nxt)
	{	if (strcmp(f->nm->s, t->lft->s) == 0)
		{	t->f = f;	// for access to f->formal
			t->a = f->body;

			if (t->a->typ == IF2
			&& !t->a->rgt->rgt)	// pending return fix
			{	t->a->rgt->rgt = new_lex(RETURN, 0, 0);
			}

			if (!f->has_fsm)
			{	f->has_fsm++;
				mk_fsm(f->body, ix);
			}
			break;
	}	}
	if (!f)
	{	fprintf(stderr, "line %d: error: no such function '%s'\n",
			t->lnr, t->lft->s);
	}
}

static void
mk_fsm(Lextok *t, const int ix)
{	Block *b;

	if (!t || (t->visit & 2))
	{	return;
	}
	t->visit |= 2;

	assert(ix >= 0 && ix < Ncore);
	
	switch (t->typ) {
	case CALL:	// function call to t->lft->s
		if (!t->c && block[ix])
		{	t->c = block[ix]->leave;
		}
		push_context(0, t->c, ix, 0); // for value of t->c, for RETURN
		block[ix]->btyp = CALL;
		 find_fct(t, ix);	// sets t->f and t->a, calls mk_fsm once
		(void) pop_context(ix, 0);
		break;
	case ';':
		t->a = t->lft;
		push_context(t->lft, t->rgt, ix, 0);
		 mk_fsm(t->lft, ix);
		(void) pop_context(ix, 0);
		mk_fsm(t->rgt, ix);
		break;
	case IF:
	case IF2:
		t->a = t->rgt->lft;
		t->b = t->rgt->rgt;
		if (!t->b && block[ix])
		{	t->b = block[ix]->leave;
		}
		mk_fsm(t->rgt->lft, ix);	// then
		mk_fsm(t->rgt->rgt, ix);	// else
		break;
	case ELSE:
		t->a = t->rgt;
		mk_fsm(t->rgt, ix);
		break;
	case WHILE:	// replace with IF2
		mk_fsm(t->rgt, ix);
		break;
	case CONTINUE:	// repeat while
		b = block[ix];
		while (b && b->btyp != IF2)
		{	b = b->nxt;
		}
		if (!b)
		{	fprintf(stderr, "error:%d: continue outside while-loop\n", t->lnr);
			t->a = new_lex(STOP, 0, 0);
			break;
		}
		t->a = b->enter;
		t->b = 0;
		break;
	case BREAK:	// complete while
		b = block[ix];
		while (b && b->btyp != IF2)
		{	b = b->nxt;
		}
		if (!b)
		{	fprintf(stderr, "error:%d: break outside while-loop\n", t->lnr);
			for (b = block[ix]; b; b = b->nxt)
			{	printf("\t%d - %2d,%2d\n",
					b->btyp,
					b->enter?b->enter->tag:0,
					b->leave?b->leave->tag:0);
			}
			sep[ix].T_stop++;
			t->a = new_lex(STOP, 0, 0);
			break;
		}
		t->a = b->leave;
		t->b = 0;
		break;
	case GOTO:
		t->a = find_label(t->lft->s);
		t->b = 0;
		break;
	case FUNCTION:
		t->a = t->c;
		break;
	case RETURN:
		b = block[ix];
		while (b && b->btyp != CALL)
		{	b = b->nxt;
		}
		t->a = b?b->leave:0;
		t->b = 0;
		break;
	default:
		b = block[ix];
		if (!b)
		{	t->a = t->b = 0;
			break;
		}
		if (b->btyp == WHILE)
		{	t->a = b->enter;
		} else
		{	t->a = b->leave;
		}
		break;
	}
}

static void
yyerror(const char *s)
{
	printf("line %d: %s ", p_lnr, s);
	if (yylval)
	{	tok2txt(yylval, stdout);
	} else
	{	printf("near '%s'\n", yytext);
	}
	sep[0].T_stop++;
}

static int
yylex(void)
{	int n = prog_lex();

	if (p_debug == 1)
	{	tok2txt(yylval, stdout);
	}
	return n;
}

static void
eval_eq(int eq, Rtype *a, Rtype *rv)	// eq=1: EQ, eq=0: NE
{
	if (a->rtyp != rv->rtyp)
	{	// can happen for a failed array lookup
		// e.g. . == 0 or . != 0
		if (a->rtyp == VAL
		&&  rv->rtyp == STR
		&&  rv->s
		&&  isdigit((uchar) rv->s[0]))
		{	rv->rtyp = VAL;
			rv->val = atoi(rv->s);
		} else if (rv->rtyp == VAL
		&& a->rtyp == STR
		&& a->s
		&& isdigit((uchar) a->s[0]))
		{	a->rtyp = VAL;
			a->val = atoi(a->s);
		} else
		{	rv->rtyp = VAL;
			rv->val  = eq?0:1;
			return;
		}
	}
	rv->rtyp = VAL;
	switch (a->rtyp) {
	case STR:
		if (!a->s)
		{	a->s = "";
		}
		// V4.4: if we compare a token text (as a string) with another string
		// as in .txt == "\\"
		// the token could be a single character "\" but the comparison text
		// cannot be written to match that, it'll be "\\"
		// the next if handles this special case:
		if (a->s[0]  == '\\' && a->s[1]  == '\0'
		&&  rv->s[0] == '\\' && rv->s[1] == '\\' && rv->s[2] == '\0')
		{	rv->val = (eq)?1:0;
			break;
		}
		if (eq)
		{	rv->val = (strcmp(a->s, rv->s) == 0);
		} else
		{	rv->val = (strcmp(a->s, rv->s) != 0);
		}
		break;
	case VAL:
		if (eq)
		{	rv->val = (a->val == rv->val);
		} else
		{	rv->val = (a->val != rv->val);
		}
		break;
	case PTR:
		if (eq)
		{	rv->val = (a->ptr == rv->ptr);
		} else
		{	rv->val = (a->ptr != rv->ptr);
		}
		break;
	default:
		yyerror("bad eq/ne types");
		break;
	}
}

void
what_type(FILE *fd, Renum t)
{
	switch (t) {
	case VAL:
		fprintf(fd, "number");
		break;
	case STR:
		fprintf(fd, "string");
		break;
	case PTR:
		fprintf(fd, "pointer");
		break;
	case STP:
		fprintf(fd, "stop");
		break;
	case PRCD:
		fprintf(fd, "proceed");
		break;
	default:
		fprintf(fd, "-unknown-");
		break;
	}
}

#define Assert(s, e, q)	\
	if (!(e))	\
	{	if (Ncore > 1) fprintf(stderr, "(%d) ", ix);	\
		fprintf(stderr, "line %d: %s: expected %s, in ", q->lnr, s, #e); \
		tok2txt(q, stderr); \
		show_error(stderr, q->lnr); \
		rv->rtyp = STP; \
		sep[ix].T_stop++;	\
		return;		\
	}

static void
set_var(Lextok *q, Rtype *rv, const int ix)
{	Var_nm *n;

	assert(ix >= 0 && ix < Ncore);
	Assert("set_var", q->typ == NAME, q);
	n = mk_var(q->s, rv->rtyp, ix);

	if (!rv->rtyp)
	{	rv->rtyp = n->rtyp;
	}

	if (n->rtyp != rv->rtyp)
	{	if (sep[ix].Verbose>1)
		{	fprintf(stderr, "\nline %d: warning: type coercion '%s'",
				q->lnr, q->s);
			fprintf(stderr, " from "); what_type(stderr, n->rtyp);
			fprintf(stderr, " to "); what_type(stderr, rv->rtyp);
			fprintf(stderr, "\n");
		}
		n->rtyp = rv->rtyp;
	}
		
	if (rv->rtyp == n->rtyp)
	{	switch (n->rtyp) {
		case STR:
			n->s = rv->s;
			break;
		case VAL:
			n->v = rv->val;
			break;
		case PTR:
			if (rv->ptr)
			{	n->pm = rv->ptr;
			} else
			{	n->pm = &none;
				n->pm->seq = 0;
			}
			break;
		default:
			break;
		}
		return;
	}

	fprintf(stderr, "line %d: error: variable '%s' has type '",
		q->lnr, q->s);
	what_type(stderr, n->rtyp);
	fprintf(stderr, "' not '");
	what_type(stderr, rv->rtyp);
	fprintf(stderr, "'\n");
	sep[ix].T_stop++;
	rv->rtyp = STP;
}

static Var_nm *
get_var(Prim **ref_p, Lextok *q, Rtype *rv, const int ix)
{	Var_nm *n = 0;
	Rtype tmp;

	if (q)
	{	assert(ix >= 0 && ix < Ncore);
		if (q->typ == NAME)
		{	if (q->core)	// qualified name
			{	eval_prog(ref_p, q->core, &tmp, ix);
				assert(tmp.rtyp == VAL);
				n = check_var(q->s, tmp.val);
			} else
			{	if (q->s)
				{	n = mk_var(q->s, 0, ix);
				} else
				{	return n;
			}	}
			rv->rtyp = n->rtyp;
		} else
		{	if (Ncore > 1) fprintf(stderr, "(%d) ", ix);
			fprintf(stderr, "line %d: unexpected variable type, in ", q->lnr);
			tok2txt(q, stderr);
			show_error(stderr, q->lnr);
			rv->rtyp = STP;
			sep[ix].T_stop++;
		}
	}
	if (0 && n)
	{	printf("get_var %s, depth %d\n", n->nm, n->cdepth);
	}
	return n;
}

extern int do_split(char *, const char *, const char *, Rtype *, const int);	// cobra_array.c

static void
split(Prim **ref_p, Lextok *q, Rtype *rv, const int ix)
{	// q->lft: source string to split on commas
	// q->rgt: name of target array,
	//  create if it doesn't exist, unset if it exists
	// returns nr of fields
	Rtype a, b, c;
	// q->s == string to split on, defaults to ","

	if (strlen(q->s) != 1)
	{	fprintf(stderr, "error: split argument '%s' is not a single character\n", q->s);
		rv->rtyp = STP;
		return;
	}

	assert(q->lft && q->rgt);
	eval_prog(ref_p, q->lft, &a, ix);
	eval_prog(ref_p, q->rgt, &b, ix);

	if (a.rtyp != STR)
	{	fprintf(stderr, "error: 1st arg of split is not a string\n");
		rv->rtyp = STP;
		return;
	}
	if (q->rgt->typ != NAME)
	{	fprintf(stderr, "error: 2nd arg of split is not a name %d, but %d\n", NAME, q->rgt->typ);
		rv->rtyp = STP;
		return;
	}

	rv->val = do_split(a.s, q->rgt->s, q->s, &c, ix);	// cobra_array.c
	rv->rtyp = VAL;						// nr of fields
}

static void
do_common(Prim **ref_p, Lextok *q, Rtype *rv, int which, const int ix)
{	Rtype a;
	char *ptr;
	// q->s == string to find

	if (q->s == 0 || strlen(q->s) != 1)
	{	fprintf(stderr, "error: %s argument '%s' is not a single character\n",
			(which == STRCHR)?"strchr":"strrchr", q->s);
		rv->rtyp = STP;
		return;
	}

	assert(q->lft && !q->rgt);
	eval_prog(ref_p, q->lft, &a, ix);

	if (a.rtyp != STR)
	{	fprintf(stderr, "error: 1st arg of split is not a string\n");
		rv->rtyp = STP;
		return;
	}
	if (which == STRCHR)
	{	ptr = strchr(a.s, (int) *(q->s));
	} else
	{	ptr = strrchr(a.s, (int) *(q->s));
	}

	if (!ptr)
	{	rv->val = 0;
	} else
	{	rv->val = 1 + (int) (ptr - a.s);
	}
	rv->rtyp = VAL;		// index of first or last match
}

static void
do_strchr(Prim **ref_p, Lextok *q, Rtype *rv, const int ix)	// index of q->s in q->lft
{
	do_common(ref_p, q, rv, STRCHR, ix);
}

static void
do_strrchr(Prim **ref_p, Lextok *q, Rtype *rv, const int ix)
{
	do_common(ref_p, q, rv, STRRCHR, ix);
}

static void
substr(Prim **ref_p, Lextok *q, Rtype *rv, const int ix)
{	// q->lft: string
	// q->rgt->lft: starting index
	// q->rgt->rgt: nr of chars
	Rtype a, b, c;

	assert(q->lft && q->rgt);
	assert(q->rgt->lft && q->rgt->rgt);

	eval_prog(ref_p, q->lft, &a, ix);
	eval_prog(ref_p, q->rgt->lft, &b, ix);
	eval_prog(ref_p, q->rgt->rgt, &c, ix);

	rv->rtyp = STR;
	rv->s = "?";

	if (a.rtyp != STR)
	{	fprintf(stderr, "error: 1st arg of substr is not a string\n");
		rv->rtyp = STP;
		return;
	}

	if (b.rtyp != VAL
	||  c.rtyp != VAL)
	{	fprintf(stderr, "error: 2nd or 3rd arg of substr is not a value\n");
		rv->rtyp = STP;
		return;
	}

	if (strlen(a.s) <= b.val)
	{	rv->s = "";
		return;
	}
	rv->s = (char *) hmalloc((c.val+1) * sizeof(char), ix, 132);		// substr
	strncpy(rv->s, &a.s[b.val], c.val);
	return;
}

static int
nr_marks_int(int a, const int ix)
{
	global_n = a;
	nr_marks_range((void *) &ix);
	return tokrange[ix]->param;
}

static char *
disambiguate(const char *s, const int ix)	// autosar checker support fct, rule M2-10-1
{	char *m, *om;
	const char *os = s;

	if (!s || *s == '\0') { return ""; }

	om = m = (char *) hmalloc(strlen(s)+1, ix, 69);

	while (*s != '\0')
	{	*m = (char) tolower((int) *s);
		switch (*s) {
		case '_': // skip
			m--;
			break;
		case 'O':		// uppercase O
		case 'o':		// lowercase o
			*m = '0';	// zero
			break;
		case 'I':
		case 'l':
			*m = '1';
			break;
		case 'S':
			*m = '5';
			break;
		case 'Z':
			*m = '2';
			break;
		case 'B':
			*m = '8';
			break;
		case 'r':
			if (*(s+1) == 'n')
			{	*m = 'm';
				s++;
			}
			break;	
		default:
			break;
		}
		m++;
		s++;
	}
	*m = '\0';

	if (verbose)
	{	printf("disambiguate: '%s' -> '%s'\n", os, om);
	}
	return om;
}

static void
print_args(Prim **ref_p, Lextok *q, Rtype *rv, const int ix)
{	FILE *tfd = (track_fd) ? track_fd : stdout;

	assert(ix >= 0 && ix < Ncore);
	switch (q->typ) {
	case ARG:
		print_args(ref_p, q->lft, rv, ix);
		print_args(ref_p, q->rgt, rv, ix);
		return;
	case MARKS:
		eval_prog(ref_p, q->lft, rv, ix);
		Assert("marks", rv->rtyp == VAL, q->lft);
		rv->val = nr_marks_int(rv->val, ix);
		fprintf(tfd, "%d", rv->val);
		return;
	case SIZE:
		fprintf(tfd, "%d", q->rgt?array_sz(q->rgt->s, ix):0);
		return;
	case DISAMBIGUATE:
		{ Var_nm *n = get_var(ref_p, q->rgt, rv, ix);
		  Assert("disambiguate", rv->rtyp == STR, q->rgt);
		  fprintf(tfd, "%s",  disambiguate((char *) n->s, ix));
		}
		return;
	case RETRIEVE:
		eval_prog(ref_p, q->lft, rv, ix);
		Assert("retrieve", rv->rtyp == VAL, q->lft);
		fprintf(tfd, "%s", array_ix(q->rgt->s, rv->val, ix));
		return;
	case SUBSTR:
		substr(ref_p, q, rv, ix);
		fprintf(tfd, "%s", rv->s);
		return;
	case SPLIT:
		split(ref_p, q, rv, ix);
		fprintf(tfd, "%s", rv->s);	// tab separated fields
		return;
	case STRCHR:
		do_strchr(ref_p, q, rv, ix);
		fprintf(tfd, "%d", rv->val);
		return;
	case STRRCHR:
		do_strrchr(ref_p, q, rv, ix);
		fprintf(tfd, "%d", rv->val);
		return;
	case STRLEN:
		eval_prog(ref_p, q->lft, rv, ix);
		Assert("strlen", rv->rtyp == STR, q->lft);
		rv->rtyp = VAL;
		rv->val = (int) strlen(rv->s);
		break;

	case NAME:
		if (q->rgt)	// q.? on q->rgt
		{	eval_prog(ref_p, q->rgt, rv, ix);
		} else		// string variable
		{	eval_prog(ref_p, q, rv, ix);
		}
		break;
	default:
		eval_prog(ref_p, q, rv, ix);
		break;
	}

	switch (rv->rtyp) {
	case VAL:
		fprintf(tfd, "%d", rv->val);
		break;
	case PTR:
		fprintf(tfd, "%p", (void *) rv->ptr);
		break;
	case STR:
		if (rv->s && strchr(rv->s, '\\'))
		{ char *s;
		  if (rv->s[1] == '\0')	// a single backslash character
		  {	fprintf(tfd, "\\");
		  } else
		  for (s = rv->s; *s != '\0'; s++)
		  {	if (*s != '\\' || *(s+1) == '\\')
			{	fprintf(tfd, "%c", *s);
		  }	}
		} else
		{ fprintf(tfd, "%s", rv->s);
		}
		break;
	default:
		break; // cannot happen
	}
}

static void
push_context(Lextok *ent, Lextok *out, int ix, int n)
{	Block *b;

	if (0 && sep[ix].P_debug == 2)
	{	printf("Push(%d:%d) N%d N%d\n", ix, n,
			ent?ent->tag:-1,
			out?out->tag:-1);
	}

	assert(ix >= 0 && ix < Ncore);

	if (b_free[ix])
	{	b = b_free[ix];
		b_free[ix] = b->nxt;
	} else
	{	if (Ncore != 1)
		{	b = (Block *) hmalloc(sizeof(Block), ix, 133);
		} else
		{	b = (Block *) emalloc(sizeof(Block), 81);
	}	}

	if (ent && ent->typ == IF2)
	{	b->btyp = IF2;
	} else
	{	b->btyp = 0;
	}
	b->enter  = ent;
	b->leave  = out;
	b->nxt    = block[ix];
	block[ix] = b;
}

static void
bfree(Block *b, int ix)
{
	assert(b);
	assert(ix >= 0 && ix < Ncore);

	b->nxt = b_free[ix];
	b_free[ix] = b;
}

static Block *
pop_context(int ix, int n)
{	Block *b;

	assert(ix >= 0 && ix < Ncore);

	if (!block[ix])
	{	return (Block *) 0;
	}
	b = block[ix];
	if (0 && sep[ix].P_debug == 2)
	{	printf("	Pop(%d:%d) N%d N%d", ix, n,
			b->enter?b->enter->tag:-1,
			b->leave?b->leave->tag:-1);
		if (b->btyp == WHILE)
		{	printf(" <while>");
		}
		printf("\n");
	}
	block[ix] = block[ix]->nxt;
	return b;
}

static void
str2val(Rtype *rv)
{
	if (rv->rtyp == STR
	&&  isdigit((uchar) rv->s[0]))
	{	rv->rtyp = VAL;
		rv->val = atoi(rv->s);
	} else if (!rv->rtyp)
	{	rv->rtyp = VAL;
		rv->val  = 0;
	}
}

static void
val2str(Rtype *rv, const int ix)
{	int aw = 64;

	if (rv->rtyp == VAL)
	{	if (rv->val >= 0 && rv->val <= 9)
		{       rv->s = nr_tbl[rv->val];
			rv->rtyp = STR;
                        return;
                }
                if (rv->val >= 0)
                {       if (rv->val < 1000)
                        {       aw = 4;
                        } else if (rv->val < 10000000)
                        {       aw = 8;
                }       }
                rv->s = (char *) hmalloc(aw, ix, 135);  // val2str
                snprintf(rv->s, aw, "%d", rv->val);     // val2str
	} else if (!rv->rtyp)
	{	rv->s = "";
	}
	rv->rtyp = STR;
}

typedef struct R_S R_S;
struct R_S {
	char *s;
	R_S *nxt;
};

#define MAXSTR	4096
#define MINSTR	  16

R_S *r_str[MAXSTR];
R_S *r_free;

#ifdef RECYCLE_STR
static void
recycle_str(char *s, const int ix)
{	int n = strlen(s)+1;
	R_S *r;

	if (n >= MINSTR && n < MAXSTR)
	{	if (r_free != NULL)
		{	r = r_free;
			r_free = r_free->nxt;
		} else
		{	r = (R_S *) hmalloc(sizeof(R_S), ix, 150);
		}
		r->s = s;
		r->nxt = r_str[n];
		r_str[n] = r;
	}
}
#endif

static void
plus(Prim **ref_p, Lextok *q, Rtype *rv, const int ix)	// strings or values
{	Rtype tmp;
	memset(&tmp, 0, sizeof(Rtype));

	assert(ix >= 0 && ix < Ncore);

	eval_prog(ref_p, q->lft, &tmp, ix);
	eval_prog(ref_p, q->rgt,   rv, ix);

	if (tmp.rtyp == STP
	||  rv->rtyp == STP)
	{	return;
	}

	if (!tmp.rtyp)
	{	tmp.rtyp = VAL;
		tmp.val = 0;
	}
	if (!rv->rtyp)
	{	rv->rtyp = VAL;
		rv->val = 0;
	}

	if (tmp.rtyp == VAL
	&&  rv->rtyp == STR)
	{	str2val(rv);
	} else if (tmp.rtyp == STR
	&&  rv->rtyp == VAL)
	{	val2str(rv, ix);
	}
	Assert("plus1", tmp.rtyp == rv->rtyp, q->lft);
	Assert("plus2", tmp.rtyp == VAL || tmp.rtyp == STR, q->rgt);

	if (tmp.rtyp == VAL)
	{	rv->val = tmp.val + rv->val;
	} else if (tmp.rtyp == STR)
	{	int n = strlen(tmp.s) + strlen(rv->s) + 1;
		char *s;
		if (n < MAXSTR && r_str[n] != NULL)
		{	R_S *r_p = r_str[n];
			s = r_str[n]->s;
			assert(strlen(s) == n-1);
			r_str[n] = r_str[n]->nxt;

			r_p->nxt = r_free;
			r_free = r_p;
		} else
		{	s = (char *) hmalloc(n, ix, 134);	// plus
		}
		snprintf(s, n, "%s%s", tmp.s, rv->s);		// plus
#ifdef RECYCLE_STR
		// noticed that some of these strings pointed to
		// are not always constant
		if (strlen(rv->s) >= MINSTR)
		{	recycle_str(rv->s, ix);
		}
		if (strlen(tmp.s) >= MINSTR)
		{	recycle_str(tmp.s, ix);
		}
#endif
		rv->s = s;
	} else
	{	fprintf(stderr, "line %d: error: invalid addition attempt\n", q->lnr);
		rv->rtyp = STP;
		sep[ix].T_stop++;
	}
}

#define binop(op)				\
	eval_prog(ref_p, q->lft, &tmp, ix);	\
	if (tmp.rtyp == STP) { break; }		\
	str2val(&tmp); 				\
	if (tmp.rtyp != VAL) { \
		printf("%d binop='	lft: ", q->lnr); \
		tok2txt(q->lft, stdout); \
		printf(" 	'%s'	rgt: ", #op); \
		tok2txt(q->rgt, stdout); \
	} \
	Assert("binop1", tmp.rtyp == VAL, q->lft);	\
	eval_prog(ref_p, q->rgt, rv, ix);	\
	if (rv->rtyp == STP) { break; }		\
	str2val(rv); 				\
	Assert("binop2", rv->rtyp == VAL, q->rgt);	\
	rv->val = tmp.val op rv->val

#define rbinop(op)				\
	eval_prog(ref_p, q->lft, &tmp, ix);	\
	if (tmp.rtyp == STP) { break; }		\
	if (tmp.rtyp != VAL) { printf("rbinop='%s'\t", #op); } \
	Assert("rbinop1", tmp.rtyp == VAL, q->lft);	\
	eval_prog(ref_p, q->rgt, rv, ix);	\
	if (rv->rtyp == STP) { break; }		\
	Assert("rbinop2", rv->rtyp == VAL && rv->val != 0, q->rgt); \
	rv->val = tmp.val op rv->val

#define unop(op)				\
	eval_prog(ref_p, q->rgt, rv, ix);	\
	str2val(rv);				\
	Assert("unop", rv->rtyp == VAL, q->rgt);	\
	rv->val = op rv->val

static void
match_anywhere(Prim **ref_p, Lextok *q, Rtype *rv, const int ix, Prim *p)
{	char *y;

	if (q->rgt->typ == NAME)
	{	rv->val = 0;
		y = p?p->txt:"";
		while ((y = strstr(y, q->rgt->s)) != NULL)
		{	rv->val++;
			y++;
		}
		return;
	}
	eval_prog(ref_p, q->rgt, rv, ix);
	switch (rv->rtyp) {
	case STR:
		rv->rtyp = VAL;
		rv->val = 0;
		y = p?p->txt:"";
		while ((y = strstr(y, rv->s)) != NULL)
		{	rv->val++;
			y++;
		}
		break;
	case VAL:
		rv->val = ~(rv->val);
		break;
	default:
		assert(ix >= 0 && ix < Ncore);
	  	printf("bad arg to ~, saw: ");
		tok2txt(q->rgt, stdout);
		printf("\n");
		sep[ix].T_stop++;
		rv->rtyp = STP;
		break;
	}
}

static void
match_at_start(Prim **ref_p, Lextok *q, Rtype *rv, const int ix, Prim *p)
{
	if (q->rgt->typ == NAME)
	{	rv->val = 0;
		if (strncmp(p?p->txt:"", q->rgt->s, strlen(q->rgt->s)) == 0)
		{	rv->val = 1;
		}
		return;
	}
	eval_prog(ref_p, q->rgt, rv, ix);
	if (rv->rtyp == STR)
	{	rv->rtyp = VAL;
		rv->val  = 0;
		if (strncmp(p?p->txt:"", rv->s, strlen(rv->s)) == 0)
		{	rv->val = 1;
		}
	} else
	{	rv->rtyp = STP;
	  	printf("bad arg to ^, saw: ");
		tok2txt(q->rgt, stdout);
		printf("\n");
		assert(ix >= 0 && ix < Ncore);
		sep[ix].T_stop++;
	}
}

static void
do_and(Prim **ref_p, Lextok *q, Rtype *rv, const int ix)
{	Rtype tmp;
	memset(&tmp, 0, sizeof(Rtype));

	assert(ix >= 0 && ix < Ncore);
	eval_prog(ref_p, q->lft, &tmp, ix);
	Assert("lhs &&", tmp.rtyp == VAL, q->lft);
	if (!tmp.val)
	{	rv->val = 0;	// shortcut
		return;
	}
	eval_prog(ref_p, q->rgt, rv, ix);
	if (rv->rtyp == PTR
	&&  rv->ptr != NULL
	&&  q->rgt->typ == '[')
	{	rv->val = rv->ptr->mark;
		rv->rtyp = VAL;
	}
	Assert("rhs &&", rv->rtyp == VAL, q->rgt);
}

static void
do_or(Prim **ref_p, Lextok *q, Rtype *rv, const int ix)
{	Rtype tmp;
	memset(&tmp, 0, sizeof(Rtype));

	assert(ix >= 0 && ix < Ncore);
	eval_prog(ref_p, q->lft, &tmp, ix);
	Assert("OR1", tmp.rtyp == VAL, q->lft);
	if (tmp.val)
	{	rv->val = 1;	// shortcut
		return;
	}
	eval_prog(ref_p, q->rgt, rv, ix);
	Assert("OR2", rv->rtyp == VAL, q->rgt);
}

#define LHS	q->lft
#define RHS	q->rgt

static void
do_incr_decr(Prim **ref_p, Lextok *q, Rtype *rv, const int ix, Prim *p)
{	Rtype tmp;
	memset(&tmp, 0, sizeof(Rtype));
	assert(ix >= 0 && ix < Ncore);
	// LHS must store a value, like .mark or q.mark
	if (LHS->typ == '[')
	{	Assert("++/--", LHS->lft && (LHS->lft->typ == NAME), LHS->lft);

		tmp.s = derive_string(ref_p, LHS->rgt, ix, 0);
		tmp.rtyp = STR;

		if (LHS->core)
		{	fprintf(stderr, "error: invalid incr/decr of %s[%s] ^ expr\n",
				LHS->lft->s, tmp.s);
			rv->rtyp = STP;
			show_error(stderr, q->lnr);
			return;
		}

		if (!incr_aname_el(ref_p, LHS->lft, &tmp, q->typ, rv, ix))	// do_incr LHS->lft->s: array name
		{	fprintf(stderr, "error: unexpected array type: expected value\n");
			show_error(stderr, q->lnr);
			rv->rtyp = STP;
		}
		return;
	}

	if (LHS->typ != '.' || !LHS->rgt || LHS->rgt->typ != MARK || RHS)
	{	if (LHS->typ == NAME)
		{	Var_nm *n;
			n = get_var(ref_p, LHS, rv, ix);
			if (n->rtyp == 0)	// first use
			{	n->rtyp = VAL;
			}
			if (n->rtyp == STR && isdigit((uchar) n->s[0]))
			{	n->rtyp = VAL;
				n->v = atoi(n->s);
			}
			if (n->rtyp == VAL)
			{	if (q->typ == INCR)
				{	rv->val = n->v + 1;
				} else if (q->typ == DECR)
				{	rv->val = n->v - 1;
				}
				n->v = rv->val;
				return;
			}
			fprintf(stderr, "line %d: error: invalid use of ++ or -- with lhs: ",
				LHS->lnr);
			tok2txt(LHS, stdout);
			fprintf(stderr, "	unexpected type: ");
			what_type(stderr, n->rtyp);
			fprintf(stderr, "\n");
		} else
		{	fprintf(stderr, "line %d: error: invalid use of ++ or -- with lhs: ",
				LHS->lnr);
			tok2txt(LHS, stderr);
		}
		rv->rtyp = STP;
		return;
	}

	eval_prog(ref_p, LHS, rv, ix);
	if (!rv->rtyp)
	{	rv->rtyp = VAL;
		rv->val  = 0;
	}
	Assert("INCR/DECR", rv->rtyp == VAL, LHS);

	if (q->typ == INCR)
	{	rv->val++;
	} else if (q->typ == DECR)
	{	rv->val--;
	}

	if (LHS->lft)	// q.mark++ or q.mark--
	{	Var_nm *n = get_var(ref_p, LHS->lft, rv, ix);

		if (!n)
		{	rv->rtyp = STP;
			return;
		}

		if (!n->rtyp)
		{	rv->rtyp = n->rtyp = PTR; // from context
		}

		if (rv->rtyp == VAL)	// stores a value
		{	n->v = rv->val;	// XX was missing before
			return;		// XX was missing before
		}

		if (rv->rtyp == PTR)
		{	Prim *z = n->pm;
			if (z)
			{	z->mark = rv->val;
				return;
			}
			fprintf(stderr, "line %d: error: incr/decr of invalid ref '%s.%s'\n",
				LHS->lnr, LHS->lft->s, LHS->rgt->s);
		} else
		{	fprintf(stderr, "line %d: error: unexpected type '", LHS->lnr);
			what_type(stderr, rv->rtyp);
			fprintf(stderr, "' in incr/decr '%s.%s'\n",
				LHS->lft->s, LHS->rgt->s);
		}
		rv->rtyp = STP;
		sep[ix].T_stop++;
		return;
	}

	if (p)	// .mark++ or .mark--
	{	p->mark = rv->val;
	}
}


static void
do_assignment(Prim **ref_p, Lextok *q, Rtype *rv, const int ix, Prim *p)
{	Rtype tmp;
	Var_nm dummy;
	memset(&tmp, 0, sizeof(Rtype));

	// restrict lhs to [q].mark = ... or . = ... or name = name:
	// LHS can be .mark or . or name
	// RHS can be .nxt, .prv, .bound, .jmp
	assert(ix >= 0 && ix < Ncore);

	if (!RHS)
	{	fprintf(stderr, "line %d: error: missing rhs in assignment\n", q->lnr);
		rv->rtyp = STP;
		return;
	}
	if (!LHS)
	{	fprintf(stderr, "line %d: error: missing lhs in assignment", q->lnr);
		rv->rtyp = STP;
		return;
	}

	if (LHS->typ == '[')
	{	Assert("set", LHS->lft && (LHS->lft->typ == NAME), LHS->lft);
		assert(RHS);
		eval_prog(ref_p, RHS, rv, ix);
		tmp.s = derive_string(ref_p, LHS->rgt, ix, 0);
		tmp.rtyp = STR;

		if (LHS->core)
		{	fprintf(stderr, "error: invalid assignment to %s[%s] ^ expr\n",
				LHS->lft->s, tmp.s);
			rv->rtyp = STP;
			show_error(stderr, q->lnr);
			return;
		}

		// lft->s: basename
		// tmp: index
		// rv: value, string, or ptr to store
		set_aname(ref_p, LHS->lft, &tmp, rv, ix);
		return;
	}

	if (LHS->typ == NAME)		// q = ... lhs
	{	eval_prog(ref_p, RHS, rv, ix);
		set_var(LHS, rv, ix);
		return;
	}

	if (LHS->typ != '.' || (LHS->lft && !LHS->rgt))
	{	printf("%d: bad lhs in assignment, expecting [name].[mark], saw: ",
			q->lnr);
		tok2txt(LHS, stdout);
		rv->rtyp = STP;
		return;
	}

	if (LHS->rgt)	// .mark = ... , q.mark = ..., .txt = ..., q.txt = ...
	{
		if (LHS->rgt->typ == TXT
		||  LHS->rgt->typ == TYP
		||  LHS->rgt->typ == FNM)
		{	eval_prog(ref_p, RHS, rv, ix);
			Assert("rhs = (a)", rv->rtyp == STR, RHS);
			if (LHS->lft)	// q.mark = ...
			{	Var_nm *n;

				switch (LHS->lft->typ) {
				case END:
				case BEGIN:
				case FIRST_T:
				case LAST_T:
					eval_prog(ref_p, LHS->lft, rv, ix);
					Assert("special", rv->rtyp == PTR, LHS->lft);
					n = &dummy;
					n->pm = rv->ptr;
					break;
				default:
					n = get_var(ref_p, LHS->lft, rv, ix);
					break;
				}

				if (rv->rtyp == 0)	// uninitialized
				{	rv->rtyp = PTR;
				}
				if (rv->rtyp == PTR)
				{	switch (LHS->rgt->typ) {
					case TXT:
						n->pm->txt = rv->s;
						n->pm->len = strlen(rv->s);
						break;
					case TYP:
						n->pm->typ = rv->s;
						break;
					case FNM:
						n->pm->fnm = rv->s;
						break;
					}
					return;
				}
				fprintf(stderr, "line %d: error: unexpected type '", LHS->lnr);
				what_type(stderr, rv->rtyp);
				fprintf(stderr, "' (%d) in assignment to '%s.%s'\n",
					rv->rtyp, LHS->lft->s, LHS->rgt->s);
				show_error(stderr, LHS->lnr);
			} else if (p)
			{	switch (LHS->rgt->typ) {
				case TXT:
					p->txt = rv->s;
					p->len = strlen(rv->s);
					break;
				case TYP:
					p->typ = rv->s;
					break;
				case FNM:
					p->fnm = rv->s;
					break;
			}	}
			return;
 		}

		if (LHS->rgt->typ == BOUND
		||  LHS->rgt->typ == PRV
		||  LHS->rgt->typ == NXT
		||  LHS->rgt->typ == JMP)
		{	Var_nm *n;
			eval_prog(ref_p, RHS, rv, ix);
			if (rv->rtyp != PTR)
			{	fprintf(stderr, "line %d: bad rhs in asgn (type %d), saw ", RHS->lnr, rv->rtyp);
				tok2txt(RHS, stderr);
				rv->rtyp = STP;
				show_error(stderr, RHS->lnr);
				return;
			}
			if (!LHS->lft)	// eg: .bound = ptr;
			{	n = &dummy;
				n->pm = p;
			} else
			{	n = get_var(ref_p, LHS->lft, &tmp, ix);
				if (!n->rtyp)			// new variable
				{	n->rtyp = PTR;		// its the q in q.mark
				}
				if (n->rtyp != PTR || !n->pm)
				{	fprintf(stderr, "line %d: error: type error in assignment to %s '",
						LHS->lnr, n->nm);
					what_type(stderr, n->rtyp);
					fprintf(stderr, "' in '%s.%s'\n", LHS->lft->s, LHS->rgt->s);
					rv->rtyp = STP;
					return;
			}	}
			switch (LHS->rgt->typ) {
			case BOUND:
				n->pm->bound = rv->ptr;
				break;
			case PRV:
				n->pm->prv = rv->ptr;
				break;
			case NXT:
				n->pm->nxt = rv->ptr;
				break;
			case JMP:
				n->pm->jmp = rv->ptr;
				break;
			}
			return;
		}

		if (LHS->rgt->typ != MARK
		&&  LHS->rgt->typ != LEN
		&&  LHS->rgt->typ != ROUND
		&&  LHS->rgt->typ != CURLY
		&&  LHS->rgt->typ != BRACKET
		&&  LHS->rgt->typ != LNR
		&&  LHS->rgt->typ != SEQ)
		{	fprintf(stderr, "line %d: error: bad lhs in asgn, saw: .",LHS->lnr);
			tok2txt(LHS->rgt, stderr);
			show_error(stderr, LHS->lnr);
			rv->rtyp = STP;
			return;
		}

		eval_prog(ref_p, RHS, rv, ix);
		if (rv->rtyp == STR && isdigit((uchar) rv->s[0]))
		{	rv->rtyp = VAL;
			rv->val = atoi(rv->s);
		} else if (rv->rtyp != VAL)
		{	printf("token: '%s'\n", rv->s);
		}
		Assert("rhs = (2)", rv->rtyp == VAL, RHS);
		// rhs is VAL
		if (LHS->lft)	// get the q in q.mark = ...
		{	Var_nm *n = get_var(ref_p, LHS->lft, &tmp, ix);

			if (!n->rtyp)			// new variable
			{	n->rtyp = PTR;		// its the q in q.mark
			}
			if (!n->pm)
			{	n->pm = (Prim *) hmalloc(sizeof(Prim), ix, 135); // do_assignment
				n->pm->fnm = n->pm->txt = n->pm->typ = "";
				n->pm->len = 0;
				n->pm->seq = -1;
			}

			if (n->rtyp == PTR)
			{	switch (LHS->rgt->typ) {
				case MARK:
					n->pm->mark = rv->val;
					break;
				case SEQ:
					n->pm->seq = rv->val;
					break;
				case LEN:
					n->pm->len = rv->val;
					break;
				case ROUND:
					n->pm->round = rv->val;
					break;
				case CURLY:
					n->pm->curly = rv->val;
					break;
				case BRACKET:
					n->pm->bracket = rv->val;
					break;
				case LNR:
					n->pm->lnr = rv->val;
					break;
				}
				return;
			}

			if (n->rtyp != VAL)
			{	fprintf(stderr, "line %d: error: type error in assignment to %s '",
					LHS->lnr, n->nm);
				what_type(stderr, tmp.rtyp);
				fprintf(stderr, "' in '%s.%s'\n", LHS->lft->s, LHS->rgt->s);
				rv->rtyp = STP;
				return;
			}
			switch (n->rtyp) {
			case VAL:
				n->v = rv->val;
				// fprintf(stderr, "%d: when can this happen? %s.%s\n",
				//	LHS->lnr, LHS->lft->s, LHS->rgt->s);
				break;
			case STP:
			case PRCD:
				break;
			case STR:
			case PTR:	// cant happen, intercepted above
			default:
				fprintf(stderr, "cannot happen, unknown type in assignment\n");
				rv->rtyp = STP;
				break;
			}
		} else if (p)	// .mark = ...
		{	switch (LHS->rgt->typ) {
			case MARK:
				p->mark = rv->val;
				break;
			case LNR:
				p->lnr = rv->val;
				break;
			case SEQ:
				p->seq = rv->val;
				break;
			case LEN:
				p->len = rv->val;
				break;
			case ROUND:
				p->round = rv->val;
				break;
			case CURLY:
				p->curly = rv->val;
				break;
			case BRACKET:
				p->bracket = rv->val;
				break;
			default:
				printf("cannot happen -- unknown typ in assign\n");
				break;
		}	}
		return;
	}

	// last case: !LHS->lft && !LHS->rgt, eg: . = ...

	eval_prog(ref_p, RHS, rv, ix);
	Assert("rhs = (3)", rv->rtyp == PTR, RHS);

	if (!(*ref_p) || !rv->ptr)
	{	if (p == tokrange[ix]->upto
		&&  RHS->typ == '.'
		&&  RHS->rgt->typ == NXT)
		{	// stay on last token
			return;
		}
		if (p == tokrange[ix]->from
		&&  RHS->typ == '.'
		&&  RHS->rgt->typ == PRV)
		{	// stay on first token
			return;
		}
		sep[ix].T_stop++;
		rv->rtyp = STP;
	} else
	{	*ref_p = rv->ptr;
	}
}

#undef LHS
#undef RHS

static void
do_dot(Prim **ref_p, Lextok *q, Rtype *rv, const int ix, Prim *p)
{
	if (!q->lft && !q->rgt)
	{	rv->rtyp = PTR;
		rv->ptr = p;
	} else if (!q->lft)
	{	eval_prog(ref_p, q->rgt, rv, ix);
	} else // q->lft	e.g.:	q.txt
	{	Var_nm *n, dummy;

		assert(ix >= 0 && ix < Ncore);
		switch (q->lft->typ) {
		case END:
		case BEGIN:
		case FIRST_T:
		case LAST_T:
			eval_prog(ref_p, q->lft, rv, ix);
			Assert("dodot", rv->rtyp == PTR, q->lft);
			n = &dummy;
			n->pm = rv->ptr;
			break;
		default:
			n = get_var(ref_p, q->lft, rv, ix);
			break;
		}
		if (!n)
		{	return;
		}
		switch (rv->rtyp) {
		case VAL:
			rv->val = n->v;
			break;
		case STR:
			rv->s = (char *) n->s;
			break;
		case PTR:
			rv->ptr = n->pm;
			if (rv->ptr)
			{	Prim *z = n->pm;
				eval_prog(&z, q->rgt, rv, ix);
				break;
			}
			rv->val  = 0;	// assume uninitialized ptr ref
			rv->rtyp = VAL;
			break;
		default:	// STP oor PRCD
			break;
	}	}
}

static void
doindent(void)
{	int i;
	for (i = 0; i < nest; i++)
	{	printf("  ");
	}
}

static void
convert2string(Prim **ref_p, Lextok *q, Rtype *rv, const int ix)
{	int aw = 64;

	assert(q->typ != ',');

	eval_prog(ref_p, q, rv, ix);

	switch (rv->rtyp) {
	case STR:
		return;
	case PTR:
		rv->val = rv->ptr->seq;	// was ->mark before
		// fall thru
	case VAL:
		if (rv->val >= 0 && rv->val <= 9)
		{	rv->s = nr_tbl[rv->val];
			break;
		}
		if (rv->val >= 0)
		{	if (rv->val < 1000)
			{	aw = 4;
			} else if (rv->val < 10000000)
			{	aw = 8;
		}	}
		rv->s = (char *) hmalloc(aw, ix, 136);	// convert2string
		snprintf(rv->s, aw, "%d", rv->val);	// convert2string
		break;
	default:	// STP or PRCD
		fprintf(stderr, "line %d: error: unexpected type of index (%d)\n",
			q->lnr, rv->rtyp);
		assert(ix >= 0 && ix < Ncore);
		sep[ix].T_stop++;
		rv->s = "?";
		break;
	}
	rv->rtyp = STR;
}

char *
derive_string(Prim **ref_p, Lextok *q, const int ix, const char *usethis) // q: comma separated list
{	Rtype tmp;
	char *s, *t, *r;
	int   n;

	memset(&tmp, 0, sizeof(Rtype));

	if (q->typ != ',')	// leaf
	{	convert2string(ref_p, q, &tmp, ix);
		if (usethis && strlen(tmp.s) < SZ_STATS)
		{	r = (char *) usethis;
		} else
		{	if (tmp.rtyp == VAL)
			{	r = tmp.s;	// V4.4: tmp.s was newly allocated
			} else
			{	r = (char *) hmalloc(strlen(tmp.s) + 1, ix, 137);	// derive_string 1
		}	}
		strcpy(r, tmp.s);
	} else
	{	s = derive_string(ref_p, q->rgt, ix, 0);
		t = derive_string(ref_p, q->lft, ix, 0);
		if (strlen(t) == 0) { printf("%s:%d: OH NO!!, unexpected error\n", (*ref_p)->fnm, (*ref_p)->lnr); }
		n = strlen(t)+strlen(s)+2;
		r = (char *) hmalloc(n, ix, 138);			// derive_string 2
		snprintf(r, n, "%s,%s", t, s);
	}
	return r;
}

static void
cpush(Prim **ref_p, const char *s, Lextok *formals, Lextok *actuals, Lextok *ra, const int ix)
{	Cstack *cframe;
	static int warned = 0;

	assert(ix >= 0 && ix < Ncore);
	for (cframe = cstack[ix]; cframe; cframe = cframe->nxt)
	{	if (strcmp(cframe->nm, s) == 0)
		{	if (!warned && sep[ix].Verbose>1)
			{	printf("line %d: warning: recursive call of %s()\n",
					actuals?actuals->lnr:0, s);
				warned = 1;
			}
			break;
	}	}
	if (Cdepth[ix] >= MAX_STACK)	// protect against infinite recursion
	{	fprintf(stderr, "error: max stackdepth of %d exceeded\n", MAX_STACK);
		sep[ix].T_stop++;
		return;
	}

	if (c_free[ix])
	{	cframe = c_free[ix];
		c_free[ix] = c_free[ix]->nxt;
	} else
	{	cframe = (Cstack *) hmalloc(sizeof(Cstack), ix, 139);
	}
	cframe->nm = s;
	cframe->ra = ra;
	cframe->formals = formals;
	cframe->actuals = actuals;
	cframe->nxt = cstack[ix];
	cstack[ix] = cframe;
	Cdepth[ix]++;	// fct call

	set_actuals(ref_p, s, formals, actuals, ix);
}

static Lextok *
cpop(const char *s, const int ix)
{	Cstack *c;

	assert(ix >= 0 && ix < Ncore);
	if (cstack[ix] && (!s || strcmp(cstack[ix]->nm, s) == 0))
	{	c = cstack[ix];
		cstack[ix] = cstack[ix]->nxt;
		c->nxt = c_free[ix];
		c_free[ix] = c;
		Cdepth[ix]--;		// fct return
		rm_aname("", 0, ix);	// all non-array vars now out of scope
		return c->ra;
	}
	fprintf(stderr, "error(%d): cannot happen: POP %s fails\n", ix, s?s:"");
	return 0;
}

static void
unwind_stack(const int ix)
{
	assert(ix >= 0 && ix < Ncore);
	while (cstack[ix])
	{	(void) cpop(0, ix);
	}
}

static int
ref_at_type(Prim *p, const char *s)
{
	if (strcmp(s, "no") == 0)
	{	return inverse;
	}
	if (strcmp(s, "ir") == 0)
	{	return inside_range;
	}
	if (strcmp(s, "and") == 0)
	{	return and_mode;
	}
	if (strcmp(s, "top") == 0)
	{	return top_only;
	}
	if (strcmp(s, "up") == 0)
	{	return top_up;
	}
	if (!p)
	{	return 0;
	}
	if (strcmp(s, "const") == 0)
	{	return (strncmp(p->typ, "const", 5) == 0);
	}
	return (strcmp(p->typ, s) == 0);
}

static int
prog_regstart(const char *s)
{	REX *r;
	int n;

	if (re_free)
	{	r = re_free;
		re_free = r->nxt;
	} else
	{	r = (REX *) emalloc(sizeof(REX), 82);
		r->rexpr = (regex_t *) emalloc(sizeof(regex_t), 82);
	}

	n = regcomp(r->rexpr, s, REG_NOSUB|REG_EXTENDED);
	if (n != 0)	// compile
	{	char ebuf[64];
		regerror(n, r->rexpr, ebuf, sizeof(ebuf));
		printf("%s\n", ebuf);
		return 0;
	}
	r->s = (char *) emalloc(strlen(s)+1, 82);
	strcpy(r->s, s);
	r->nxt = re_lst;
	re_lst = r;
	return 1;
}

static int
prog_regmatch(const char *q, const char *s)
{	REX *t;

	for (t = re_lst; t; t = t->nxt)
	{	if (strcmp(t->s, s) == 0)
		{	break;
	}	}
	if (!t)
	{	if (!prog_regstart(s))
		{	return 0;
		}
		t = re_lst;
	}
	return (regexec(t->rexpr, q, 0,0,0) == 0);
}
#if 0
static void
prog_regstop(void)
{	REX *t;

	for (t = re_lst; t; t = t->nxt)
	{	regfree(t->rexpr);
	}
	re_free = re_lst;
	re_lst  = 0;
}
#endif

// End RegEx

static char *
set_pre(Prim **ref_p, Lextok *t, int ix, int txt)
{	Prim *w = *ref_p;
	Rtype tmp;
	char *s;

	memset(&tmp, 0, sizeof(Rtype));

	assert(t->rgt && t->rgt->typ == STRING);
	if (!t->lft)
	{	if (!w)
		{	return "";
		}
		return txt?w->txt:w->typ;
	}
	eval_prog(ref_p, t->lft, &tmp, ix);
	assert(tmp.rtyp == STR);
	s = (char *) hmalloc(strlen(tmp.s)+1, ix, 140);	// set_pre
	strcpy(s, tmp.s);
	return s;
}


static int
re_matches(Prim **ref_p, Lextok *t, int cid)
{	char *v;
	char *s = t->rgt->s;
	int isre = 0;
	int istxt = 1;
	int rv;


	if (*s == '\\')
	{	s++;
	} else if (*s == '/')
	{	s++;
		isre++;
	} else if (*s == '@')
	{	s++;
		istxt = 0;
	}

	do_lock(cid);

	v = set_pre(ref_p, t, cid, istxt);
	if (isre)
	{	rv = prog_regmatch(v, s);
	} else
	{	if (!istxt
		&&  strcmp(v, "const") == 0)
		{	rv = (strncmp(v, "const", 5) == 0);
		} else
		{	rv = (strcmp(v, s) == 0);
	}	}

	do_unlock(cid);

	return rv;
}

static int
sum_var(const char *s)
{	Var_nm *n;
	int i, j, sum = 0;
	ulong h2 = hash2(s);

	// sum a variable's value across all cores

	for (i = 0; i < Ncore; i++)
	{	for (n = v_names[i]; n; n = n->nxt)	// mk_var
		{	if (n->h2 > h2)
			{	break;
			}
			if (n->h2 == h2
			&&  strcmp(n->nm, s) == 0)
			{	j = 0;
				switch (n->rtyp) {
				case VAL:
					j = n->v;
					break;
				case STR:
					if (isdigit((uchar) n->s[0]))
					{	j = atoi(n->s);
					} else if (strlen(n->s) > 0)
					{	j = 1;
					}
					break;
				case PTR:
					if (n->pm && n->pm->lnr > 0)
					{	j = 1;
					}
					break;
				default:
					break;
				}
				sum += j;
	}	}	}

	return sum;
}

static int
do_sum(Prim **ref_p, Lextok *q, Rtype *rv, int ix)
{	char *s;

	// q->lft is array name
	// q->rgt is array index, if any
	// or q->typ == NAME

	rv->rtyp = VAL;

	if (q->typ == NAME)
	{	return sum_var(q->s);
	}

	if (q->typ == '[')
	{	s = derive_string(ref_p, q->rgt, ix, 0);
		return array_sum_el(q->lft->s, s);
	}

	fprintf(stderr, "%d: bad arg for sum, saw: ", q->lnr);
	tok2txt(q, stderr);
	show_error(stderr, q->lnr);
	rv->rtyp = STP;

	return 0;
}

static int
save_int(int a, char *b, Rtype *rv, const int ix)
{
	if (strcmp(b, "|") == 0
	||  strcmp(b, "&") == 0
	||  strcmp(b, "^") == 0
	||  strlen(b) == 0)
	{	global_n = a;
		global_t = b;
		save_range((void *) &ix);
		return tokrange[ix]->param;
	}
	rv->rtyp = STP;
	printf("usage: save(n, \"\" or \"|\" or \"&\" or \"^\"\n");
	return 0;
}

static int
restore_int(int a, char *b, Rtype *rv, const int ix)
{	char as[32];

	sprintf(as, "%d", a);
	if (strcmp(b, "|") == 0
	||  strcmp(b, "&") == 0
	||  strcmp(b, "^") == 0
	||  strlen(b) == 0)
	{	global_n = a;
		global_t = b;
		restore_range((void *) &ix);
		return tokrange[ix]->param;
	}
	rv->rtyp = STP;
	printf("usage: restore(n, \"\" or \"|\" or \"&\" or \"^\"\n");
	return 0;
}

void
fcts_int(const int ix)
{	FList *f;
	Prim *z;

	if (!flist)
	{	flist = (FList **) emalloc(Ncore * sizeof(FList *), 83);
		fct_defs_range((void *) &ix);
	}

	for (f = flist[ix]; f; f = f->nxt)
	{	z = f->p;	// fct name
		if (z->jmp)
		{	z = z->jmp;
			if (z->prv)
			{	z->prv->mark++;
			} else
			{	z->mark++;
			}
		} else
		{	z->mark++;
	}	}
}

void
reset_int(const int ix)
{
	(void) clear_range((void *) &ix);
}

static void
new_scalar(char *s, int ix)
{	Var_nm *g = mk_var(s, 0, ix);

	if (g)
	{	if (verbose)
		{	printf("global scalar %s\n", s);
		}
		g->cdepth = 0;
	} else
	{	fprintf(stderr, "error: global decl of %s failed, cpu %d\n", s, ix);
	}
}

static void
new_global(Lextok *q)
{	int i;
	if (q->typ != NAME)
	{	printf("new_global: unexpected type %d\n", q->typ);
		return;
	}
	for (i = 0; i < Ncore; i++)
	{	if (q->rgt && q->rgt->typ == '[')
		{	new_array(q->s, i);
		} else
		{	new_scalar(q->s, i);
	}	}
}

static void
handle_global(Lextok *t)
{
	if (!t)
	{	return;
	}

	handle_global(t->lft);

	if (t->typ == ',')
	{	new_global(t->rgt);
	} else if (t->typ == NAME)
	{	new_global(t);
	}
}

static void
bad_ref(const Var_nm *n, const Rtype *rv, const Lextok *from)
{
	if (!n)
	{	fprintf(stderr, "error: '%s' not found\n", from->s);
	} else if (rv->rtyp != PTR)
	{	fprintf(stderr, "error: '%s' bad token ref\n", from->s);
	}
}

static Prim *
handle_arg(Prim **ref_p, Lextok *from, Rtype *rv, const int ix)
{	Var_nm *n;

	if (!from)
	{	fprintf(stderr, "error: add/del_pattern (internal error)\n");
		return NULL;
	}

	if (from->typ == '.')
	{	return *ref_p;
	}

	if (from->typ != NAME)
	{	fprintf(stderr, "error: bad add/del_pattern command\n");
		return NULL;
	}

	n = get_var(ref_p, from, rv, ix);
	if (!n || rv->rtyp != PTR || !n->pm)
	{	bad_ref(n, rv, from);
		return NULL;
	}

	return n->pm;
}

static int
get_cumulative(Prim **ref_p, Lextok *q, Rtype *rv, int with_start, const int ix)
{	int cntr, nb = 0;
	ulong cumulative;
	int na, sv = 0;	// default start value

	// 0: retrieve array size and the optional start index

	na = array_sz(q->lft->s, ix);
	if (na <= 0)
	{	return 1;	// not an array
	}

	if (with_start)
	{	eval_prog(ref_p, q->rgt, rv, ix);
		if (rv->rtyp == STR && isdigit((int) (rv->s[0])))
		{	rv->val = atoi(rv->s);
		} else if (rv->rtyp != VAL)
		{	return 2;	// not start value given
		}
		sv = rv->val;

		// 1: find the starting index in the array
#if 1
		nb = na-sv-1;
		rv->s = array_ix(q->lft->s, nb, ix);
		rv->rtyp = STR;
#else
		for (cntr = 0, nb = na-1; cntr < na; cntr++, nb--)
		{	rv->s = array_ix(q->lft->s, nb, ix);
			if (atoi(rv->s) == sv)
			{	break;	// found
		}	}
		if (cntr == na)	// not found
		{	printf("error: index %d not found in array %s\n", sv, q->lft->s);
			return 3;
		}
#endif
		assert(nb >= 0 && nb < na);
	}

	// printf("'%s' is an array of size: %d -- start @ %d found at %d\n", q->lft->s, na, sv, nb);

	// 2: compute the cumulative hash over the array elements
	//    backwards from nb, modulo na

	eval_aname(ref_p, q, rv, ix); 		// retrieve string stored
	assert(rv->rtyp == STR);
	cumulative = hash2_cum(rv->s, 0);	// initialize and first call

	for (cntr = 1; cntr < na; cntr++)
	{	nb = (nb == 0)? na-1 : nb-1;
		rv->s = array_ix(q->lft->s, nb, ix);
		rv->rtyp = STR;
		eval_aname(ref_p, q, rv, ix); // retrieve string stored
		assert(rv->rtyp == STR);
		cumulative = hash2_cum(rv->s, cntr);
	}
	rv->val = cumulative;
	rv->rtyp = VAL;

	return 0;
}

void
eval_prog(Prim **ref_p, Lextok *q, Rtype *rv, const int ix)
{	Prim  *p;
	Rtype tmp;

	memset(&tmp, 0, sizeof(Rtype));
	assert(ix >= 0 && ix < Ncore);
	sep[ix].Nest++;
next:
	if (!q || sep[ix].T_stop)
	{	if (sep[ix].P_debug == 2)
		{	nest = sep[ix].Nest;
			doindent();
			printf("--%s\n", !q?"path ends":"stopped");
		}
		sep[ix].Nest--;
		if (!rv->rtyp)
		{	rv->rtyp = VAL;
			rv->val  = 0;
		}
		return;		// the only return from the function
	}

	p        = *ref_p;
	rv->rtyp = VAL;		// default type
	rv->val  = 0;		// default value
	p_lnr    = q->lnr;

	if (sep[ix].Verbose > 2)
	{	lock_print(ix);
		printf("%d: [seq %d ln %d] EVAL_PROG typ %3d ",
			ix, p->seq, p->lnr, q->typ);
		tok2txt(q, stdout);
		fflush(stdout);
		unlock_print(ix);
	}
	if (sep[ix].P_debug == 2)
	{	doindent();
		printf("%d | %d | %d ::%d:'%s:%d: %s:%s'\t",
			q->tag,
			q->a?q->a->tag:0,
			q->b?q->b->tag:0,
			p->seq, p->fnm, p->lnr,
			p->typ, p->txt);
		tok2txt(q, stdout);
	}
	switch (q->typ) {
	case     NR: rv->val = q->val; break;
	case   TRUE: rv->val = 1; break;
	case  FALSE: rv->val = 0; break;
	case    '#': rv->val = !strcmp(p?p->txt:"", q->rgt->s); break;
	case    '@': rv->val = ref_at_type(p, q->rgt->s); break; 
	case    CPU: rv->val = ix; break;
	case N_CORE: rv->val = Ncore; break;

	case   BEGIN: rv->ptr = tokrange[ix]->from; rv->rtyp = PTR; break;
	case     END: rv->ptr = tokrange[ix]->upto; rv->rtyp = PTR; break;
	case FIRST_T: rv->ptr = prim; rv->rtyp = PTR; break;
	case  LAST_T: rv->ptr = plst; rv->rtyp = PTR; break;

	case MARKS:
		eval_prog(ref_p, q->lft, rv, ix);
		Assert("marks", rv->rtyp == VAL, q->lft);
		rv->val = nr_marks_int(rv->val, ix);
		break;

	case  SIZE:
		Assert("size", q->rgt && q->rgt->typ == NAME, q->rgt);
		rv->val = array_sz(q->rgt->s, ix);
		break;

	case SUM:
		rv->val = do_sum(ref_p, q->rgt, rv, ix);
		break;

	case RETRIEVE:
		Assert("retrieve", q->rgt && q->rgt->typ == NAME, q->rgt);
		eval_prog(ref_p, q->lft, rv, ix);
		Assert("index2", rv->rtyp == VAL, q->lft);
		rv->rtyp = STR;
		rv->s = array_ix(q->rgt->s, rv->val, ix);
		break;

	case SET_RANGES:
		{	Prim *a, *b;
			eval_prog(ref_p, q->lft, rv, ix);	// from
			Assert("set_range1", rv->rtyp == PTR, q->lft);
			a = rv->ptr;
			eval_prog(ref_p, q->rgt, rv, ix);	// upto
			Assert("set_range2", rv->rtyp == PTR, q->rgt);
			b = rv->ptr;
			set_ranges(a, b, 10);
		}
		rv->rtyp = VAL;
		rv->val  = 0;
		break;

	case SUBSTR:
		substr(ref_p, q, rv, ix);
		break;

	case SPLIT:
		split(ref_p, q, rv, ix);
		break;

	case STRCHR:
		do_strchr(ref_p, q, rv, ix);
		break;

	case STRRCHR:
		do_strrchr(ref_p, q, rv, ix);
		break;

	case STRLEN:
		eval_prog(ref_p, q->lft, rv, ix);
		Assert("strlen", rv->rtyp == STR, q->lft);
		rv->rtyp = VAL;
		rv->val  = strlen(rv->s);
		break;

	case FCTS:
		fcts_int(ix);
		rv->rtyp = VAL;
		rv->val = 0;
		break;

	case RESET:
		reset_int(ix);
		rv->rtyp = VAL;
		rv->val = 0;
		break;

	case SAVE:	// eg: save(2, "|")
		{	int tv;
			eval_prog(ref_p, q->lft, rv, ix);
			Assert("save", rv->rtyp == VAL, q->lft);
			tv = rv->val;
			eval_prog(ref_p, q->rgt, rv, ix);
			Assert("save", rv->rtyp == STR, q->rgt);
			rv->rtyp = VAL;
			rv->val = save_int(tv, rv->s, rv, ix);
		}
		break;

	case RESTORE:
		{	int tv;
			eval_prog(ref_p, q->lft, rv, ix);
			Assert("restore", rv->rtyp == VAL, q->lft);
			tv = rv->val;
			eval_prog(ref_p, q->rgt, rv, ix);
			Assert("restore", rv->rtyp == STR, q->rgt);
			rv->rtyp = VAL;
			rv->val = restore_int(tv, rv->s, rv, ix);
		}
		break;

	case RE_MATCH:
		rv->rtyp = VAL;
		rv->val  = re_matches(ref_p, q, ix);
		break;

	case ITOSTR:
		convert2string(ref_p, q->lft, rv, ix);
		break;

	case '[':
		if (q->rgt && q->rgt->typ == ',')
		{	rv->rtyp = STR;
			rv->s = derive_string(ref_p, q->rgt, ix, 0); // '['
		} else
		{	Assert(q->lft?q->lft->s:"?", q->lft && (q->lft->typ == NAME), q->lft);
			Assert("[", q->rgt, q);
			convert2string(ref_p, q->rgt, rv, ix); // index
		}
		eval_aname(ref_p, q, rv, ix); // '[' array name, index value
		break;

	case  OR: do_or( ref_p, q, rv, ix); break;
	case AND: do_and(ref_p, q, rv, ix); break;

	case  B_OR: binop(|); break;
	case B_AND: binop(&); break;

	case LSH: binop(<<); break;
	case RSH: binop(>>); break;

	case B_XOR: binop(^); break;

	case  GT: binop(>);  break;
	case  LT: binop(<);  break;
	case  GE: binop(>=); break;
	case  LE: binop(<=); break;
	case '+': plus(ref_p, q, rv, ix); break;
	case '-': binop(-); break;
	case '*': binop(*);  break;
	case '/': rbinop(/);  break;
	case '%': rbinop(%);  break;
	case UMIN: unop(-);  break;
	case '!':  unop(!);  break;

	case '~': match_anywhere(ref_p, q, rv, ix, p); break;
	case '^': match_at_start(ref_p, q, rv, ix, p); break;

	case   ROUND: rv->val = p?p->round:0; break;
	case BRACKET: rv->val = p?p->bracket:0; break;
	case   CURLY: rv->val = p?p->curly:0; break;
	case     LEN: rv->val = p?p->len:0; break;
	case	 LNR: rv->val = p?p->lnr:0; break;
	case    MARK: rv->val = p?p->mark:0; break;
	case     SEQ: rv->val = p?p->seq:0; break;

	case	RANGE:
		  if (p && (p->bound || p->jmp))
		  {	Prim *d = p->bound?p->bound:p->jmp;
			if (strcmp(d->fnm, p->fnm) == 0)
			{	rv->val = d->lnr - p->lnr;
				break;
		  }	}
		  rv->val = 0;
		  break;

	case EQ: eval_prog(ref_p, q->lft, &tmp, ix);
		 eval_prog(ref_p, q->rgt, rv, ix);
		 eval_eq(1, &tmp, rv);
		 break;

	case NE: eval_prog(ref_p, q->lft, &tmp, ix);
		 eval_prog(ref_p, q->rgt, rv, ix);
		 eval_eq(0, &tmp, rv);
		 break;

	case '.':
		 if (!q->lft && q->rgt)
		 {	q = q->rgt;
			goto next; // avoid recursion
		 }
		 do_dot(ref_p, q, rv, ix, p);
		 break;

	case PRINT:
		print_args(ref_p, q->lft, rv, ix);
		fflush(stdout);
		break;

	case NAME:
		{ Var_nm *n = get_var(ref_p, q, rv, ix);
		  switch (rv->rtyp) {
		  case VAL:
			rv->val = n->v;
			break;
		  case STR:
			rv->s = (char *) n->s;
			break;
		  case PTR:
			rv->ptr = n->pm;
			break;
		  default:
			break;
		  }
		}
		break;

	case STRING: rv->rtyp = STR; rv->s   = q->s; break;
	case    FCT: rv->rtyp = STR; rv->s   = fct_which(p); break;
	case    FNM: rv->rtyp = STR; rv->s   = p?p->fnm:"";  break;
	case    TYP: rv->rtyp = STR; rv->s   = p?p->typ:"";  break;
	case    TXT: rv->rtyp = STR; rv->s   = p?p->txt:"";  break;
	case    JMP: rv->rtyp = PTR; rv->ptr = p?p->jmp:p;  break;
	case  BOUND: rv->rtyp = PTR; rv->ptr = p?p->bound:p; break;
	case MBND_D: rv->rtyp = PTR; rv->ptr = p?p->mbnd[0]:p; break;
	case MBND_R: rv->rtyp = PTR; rv->ptr = p?p->mbnd[1]:p; break;
	case    NXT: rv->rtyp = PTR; rv->ptr = p?p->nxt:p;   break;
	case    PRV: rv->rtyp = PTR; rv->ptr = p?p->prv:p;   break;

	case INCR:
	case DECR: do_incr_decr(ref_p,  q, rv, ix, p); break;
	case  '=': do_assignment(ref_p, q, rv, ix, p); p = *ref_p; break;

	case IF:
	case IF2:
		eval_prog(ref_p, q->lft, rv, ix);
		if (rv->rtyp == STP)
		{	break;
		}
		Assert("if", rv->rtyp == VAL, q->lft);
		if (rv->val)		// then part
		{	if (sep[ix].P_debug == 2)
			{	doindent();
				printf("Then\n");
			}
			q = q->a;
			goto next;
		} else if (q->b)	// else part
		{	if (sep[ix].P_debug == 2)
			{	doindent();
				printf("Else\n");
			}
			q = q->b;
			goto next;
		} else			// no else
		{	rv->rtyp = PRCD;
			if (sep[ix].P_debug == 2)
			{	doindent();
				printf("Up\n");
		}	}
		break;

	case BREAK:
		if (!q->a)
		{	rv->rtyp = PRCD;
			if (sep[ix].P_debug == 2)
			{	doindent();
				printf("Up (break/return)\n");
		}	}
	case ';':
	case CONTINUE:
	case ELSE:
	case SKIP:
	case GOTO:
		break;

	case ADD_PATTERN:	// name q->lft, from q->rgt->lft, upto q->rgt->rgt
	case DEL_PATTERN:
		if (q->lft
		&&  q->rgt
		&&  q->rgt->lft
		&&  q->rgt->rgt)
		{	Prim *f, *u;

			f = handle_arg(ref_p, q->rgt->lft, rv, ix); // from
			u = handle_arg(ref_p, q->rgt->rgt, rv, ix); // upto

			if (f && u)
			{	char *tmp_nm = "unknown";
				if (q->lft->typ == STRING)
				{	tmp_nm = q->lft->s;
				} else if (q->lft->typ == NAME)
				{	tmp_nm = q->lft->s;
					if (!is_pset(q->lft->s))
					{	Var_nm *n = get_var(ref_p, q->lft, rv, ix);
						if (rv->rtyp == STR)
						{	tmp_nm = n->s;
						}
					}
				} else
				{	goto error_case;
				}
				if (verbose)
				{	printf("%s_pattern to set '%s' from %s:%d upto %s:%d\n",
						(q->typ == ADD_PATTERN) ? "add" : "del",
						tmp_nm, f->fnm, f->lnr, u->fnm, u->lnr);
				}
				if (q->typ == ADD_PATTERN)
				{	add_pattern(tmp_nm, 0, f, u, ix);
				} else
				{	del_pattern(tmp_nm, f, u, ix);
				}
				break;
			}
		}
	error_case:
		show_error(stderr, q->lnr);
		unwind_stack(ix);
		sep[ix].T_stop++; 
		rv->rtyp = STP;
		break;
	case CP_PSET:
		if (q->lft->typ == STRING)
		{	rv->ptr = cp_pset(q->lft->s, ix);
		} else if (q->lft->typ == NAME)
		{	rv->ptr = cp_pset(q->lft->s, ix);
			if (rv->ptr == 0)	// could be a var
			{	Var_nm *n = get_var(ref_p, q->lft, rv, ix);
				if (rv->rtyp == STR)
				{	rv->ptr = cp_pset(n->s, ix);
				}
				if (rv->ptr == 0)
				{	rv->rtyp = PTR;
					break; // valid syntax, but set does not exist (yet)
			}	}
		} else
		{	fprintf(stderr, "error: pset arg is not a var, name, or string'\n");
			rv->ptr = NULL;
		}
		if (!rv->ptr)
		{	show_error(stderr, q->lnr);
			unwind_stack(ix);
			sep[ix].T_stop++; 
			rv->rtyp = STP;
		} else
		{	rv->rtyp = PTR;
		}
		break;

	case HASHARRAY:
		if (q->lft->typ == NAME)
		{	// associative array of na elements
			// return incremental hash over all string elements stored
			// starting at index rv->val

			if (get_cumulative(ref_p, q, rv, 1, ix) == 0)
			{	break;
		}	} // else, an error code was returned and reported

		fprintf(stderr, "error: hash arg %s is not an array of strings\n", q->lft->s);
		show_error(stderr, q->lnr);
		unwind_stack(ix);
		sep[ix].T_stop++; 
		rv->rtyp = STP;	
		break;

	case HASH:	// V 4.5
		eval_prog(ref_p, q->lft, rv, ix);
		if (rv->rtyp == STR)
		{	ulong h1 = hash3(rv->s);
			rv->val = h1;
			rv->rtyp = VAL;
			break;
		}
		if (q->lft->typ == NAME)
		{	Var_nm *n = get_var(ref_p, q->lft, rv, ix);
			if (rv->rtyp == STR)
			{	ulong h1 = hash3(n->s);
				rv->val = h1;
				rv->rtyp = VAL;
				break;
			} // else, it is not a scalar var
			if (get_cumulative(ref_p, q, rv, 0, ix) == 0)
			{	break; // default start value 0
		}	}

		fprintf(stderr, "error: hash arg %s does not evaluate to a string'\n", q->lft->s);
		show_error(stderr, q->lnr);
		unwind_stack(ix);
		sep[ix].T_stop++; 
		rv->rtyp = STP;	
		break;

	case IS_PATTERN:	// Kenneth McLarney
		rv->rtyp = VAL;
		if (q->lft->typ == STRING)
		{	rv->val = setexists(q->lft->s);
		} else if (q->lft->typ == NAME)
		{	rv->val = setexists(q->lft->s);
			if (rv->val == 0)	// check if var
			{	Var_nm *n = get_var(ref_p, q->lft, rv, ix);
				if (rv->rtyp == STR)
				{	rv->val = setexists(n->s);
				} else
				{	rv->val = 0;
				}
				rv->rtyp = VAL; // restore
			}
		} else
		{	fprintf(stderr, "error: arg is not a var, name, or string'\n");
			show_error(stderr, q->lnr);
			unwind_stack(ix);
			sep[ix].T_stop++; 
			rv->rtyp = STP;
		}
		break;

	case ASSERT:
		eval_prog(ref_p, q->lft, rv, ix);
		Assert("assert", rv->rtyp == VAL, q->lft);
		if (rv->val == 0)
		{	fprintf(stderr, "%s:%d: assertion violated at: ",
				p->fnm, p->lnr);
			Prim *z = p;
			while (z->prv && z->lnr == z->prv->lnr) { z = z->prv; }
			while (z)
			{	fprintf(stderr, "%s", z->txt);
				z = z->nxt;
				if (!z || z->lnr != p->lnr)
				{	break;
			}	}
			fprintf(stderr, "\n");
#ifdef DEBUG
			dump_tree(q->lft, 0);
#endif
			if (0) fprintf(stderr, "%d: [seq %d ln %d] EVAL_PROG typ %3d ",
				ix, p->seq, p->lnr, q->typ);

			show_error(stderr, q->lnr);
			unwind_stack(ix);
			sep[ix].T_stop++; 
			rv->rtyp = STP;
			break;
		}
		break;

	case SRC_LN:	// V 4.5
		{	int from_nr, upto_nr;
			char *from_fnm;

			Assert("src_ln0", q->lft && q->lft->lft && q->lft->rgt && q->rgt, q);

			eval_prog(ref_p, q->rgt, rv, ix);	// upto
			Assert("src_ln3", rv->rtyp == VAL, q->rgt);
			upto_nr = rv->val;

			eval_prog(ref_p, q->lft->rgt, rv, ix);	// from
			Assert("src_ln2", rv->rtyp == VAL, q->lft->rgt);
			from_nr = rv->val;
			Assert("src_ln2", from_nr <= upto_nr, q->lft->rgt);

			eval_prog(ref_p, q->lft->lft, rv, ix);	// fnm
			Assert("src_ln1", rv->rtyp == STR, q->lft->lft);
			from_fnm = rv->s;

			show_line(stdout, from_fnm, -1, from_nr, upto_nr, 0);
		}
		break;

	case TERSE:
		rv->val = no_display;
		break;

	case VERBOSE:
		rv->val = sep[ix].Verbose;
		break;

	case ',':	// associate array index, list of exprs
			// replace with single string
		rv->rtyp = STR;
		rv->s = derive_string(ref_p, q, ix, 0);
		break;

	case NEXT_T: unwind_stack(ix); sep[ix].T_stop++; rv->rtyp = PRCD; break;
	case STOP:   unwind_stack(ix); sep[ix].T_stop++; rv->rtyp = STP;  break;

	case WHILE:		// replaced with IF2
		assert(0);	// not reachable
		break;
	case FUNCTION:	// function definition
		break;
	case CALL:	// function call, body in q->a, actuals in q->rgt
		if (!q->f)	// fct call in expr
		{	find_fct(q, ix);	// sets q->f and q->a, calls mk_fsm once
		}
#if 0
		assert(q->f);	// was set in mk_fsm
		assert(q->a);
#endif	
		if (!q->f || !q->a)
		{	rv->rtyp = STP;
		} else
		{	cpush(ref_p, q->f->nm->s, q->f->formal, q->rgt, q->c, ix);
			eval_prog(ref_p, q->a, rv, ix);
		}
		q = 0;
		break;

	case RETURN:
		if (q->lft)
		{	eval_prog(ref_p, q->lft, rv, ix);
		} else
		{	rv->rtyp = VAL;
			rv->val  = 0;
		}
		// q->a value was set in mk_fsm
		q->a = cpop(0, ix);
		break;

	case UNSET:
		rm_aname_el(ref_p, q, ix);
		break;

	case LOCK:
		do_lock(ix);
		break;
	case UNLOCK:
		do_unlock(ix);
		break;

	case A_UNIFY:
		array_unify(q, ix);
		break;

	case NEWTOK:
		rv->ptr = (Prim *) hmalloc(sizeof(Prim), ix, 141);		// newtok
		rv->ptr->seq = 0;
		rv->ptr->txt = rv->ptr->typ = rv->ptr->fnm = "";
		rv->ptr->len = 0;
		rv->rtyp = PTR;
		break;

	case DISAMBIGUATE:
		// q->rgt->s is of type NAME (a variable)
		// a variable that should be of type STR
		{ Var_nm *n = get_var(ref_p, q->rgt, rv, ix);
		  Assert("disambiguate", rv->rtyp == STR, q->rgt);
		  rv->s = disambiguate((char *) n->s, ix);
		}
		break;

	// list functions
	case TOP:
		//Assert("top", q->lft != NULL, q);
		rv->rtyp = PTR;
		rv->ptr = top(q->lft->s, ix);
		break;
	case BOT:
		//Assert("bot", q->lft != NULL, q);
		rv->rtyp = PTR;
		rv->ptr = bot(q->lft->s, ix);
		break;
	case OBTAIN_EL:
		rv->rtyp = PTR;
		rv->ptr = obtain_el(ix);
		break;
	case RELEASE_EL:
		eval_prog(ref_p, q->lft, rv, ix);
		//Assert("release_el", rv->rtyp == PTR, q->lft);
		release_el(rv->ptr, ix);
		rv->rtyp = VAL;
		rv->val = 0;
		break;
	case POP_TOP:
		//Assert("pop_top", q->lft != NULL, q);
		pop_top(q->lft->s, ix);
		rv->rtyp = VAL;
		rv->val = 0;
		break;
	case POP_BOT:
		//Assert("pop_bot", q->lft != NULL, q);
		pop_bot(q->lft->s, ix);
		rv->rtyp = VAL;
		rv->val = 0;
		break;
	case UNLIST:
		//Assert("unlist", q->lft != NULL, q);
		unlist(q->lft->s, ix);
		rv->rtyp = VAL;
		rv->val = 0;
		break;
	case LLENGTH:
		//Assert("unlist", q->lft != NULL, q);
		rv->rtyp = VAL;
		rv->val = llength(q->lft->s, ix);
		break;
	case ADD_TOP:
		eval_prog(ref_p, q->rgt, rv, ix);
		//Assert("add_top1", rv->rtyp == PTR, q->rgt);
		//Assert("add_top2", q->lft != NULL, q);
		add_top(q->lft->s, rv->ptr, ix);
		rv->rtyp = VAL;
		rv->val = 0;
		break;
	case ADD_BOT:
		eval_prog(ref_p, q->rgt, rv, ix);
		//Assert("add_bot1", rv->rtyp == PTR, q->rgt);
		//Assert("add_bot2", q->lft != NULL, q);
		add_bot(q->lft->s, rv->ptr, ix);
		rv->rtyp = VAL;
		rv->val = 0;
		break;
	// end list functions

	case GLOBAL:
		break;

	case FOR:
	default:
		printf("line %d: cannot happen: %d (%s) ", q->lnr, q->typ, q->s);
		tok2txt(q, stdout);
		rv->rtyp = STP;
		break;
	}

	if (rv->rtyp == STP
	||  rv->rtyp == PRCD
	|| !q)
	{	q = 0;
	} else
	{	switch (q->typ) {
		case ';':
		case '=':
		case ADD_PATTERN:
		case DEL_PATTERN:
		case ASSERT:
		case INCR:
		case DECR:
		case PRINT:
		case BREAK:
		case CONTINUE:
		case GLOBAL:
		case GOTO:
		case SKIP:
		case ELSE:
		case UNSET:
		case FUNCTION:
		case RETURN:
		case A_UNIFY:
		case LOCK:
		case UNLOCK:
		case FCTS:
		case SAVE:
		case RESET:
		case SRC_LN:

		case TOP:
		case BOT:
		case ADD_TOP:
		case ADD_BOT:
		case POP_TOP:
		case POP_BOT:
		case OBTAIN_EL:
		case RELEASE_EL:
		case UNLIST:
		case LLENGTH:

		case RESTORE:
			q = q->a;
			break;
		case CALL:
			break;
		default:
			q = 0;
			break;
		}
	}
	if (sep[ix].P_debug == 2)
	{	doindent();
		printf("--end eval_prog rv: '");
		what_type(stdout, rv->rtyp);
		printf("' val %d --> str: %s\n",
			rv->val, (rv->rtyp == STR)?rv->s:"");
	}
	goto next;
}

static Var_nm *
check_var(const char *s, const int ix)
{	static Var_nm dummy;
	Var_nm *n, *g = &dummy;
	ulong h2 = hash2(s);

	assert(ix >= 0 && ix < Ncore);
	for (n = v_names[ix]; n; n = n->nxt)	// check_var
	{	if (n->h2 > h2)
		{	break;
		}
		if (n->h2 == h2
		&&  strcmp(n->nm, s) == 0)
		{	if (n->cdepth == Cdepth[ix])
			{	return n;	// found
			}
			if (n->cdepth == 0)
			{	g = n;
	}	}	}

	return g;
}

static Var_nm *
mk_var(const char *s, const int t, const int ix)
{	Var_nm *n, *g = (Var_nm *) 0;
	Var_nm *lastn = NULL;
	ulong h2 = hash2(s);

	assert(ix >= 0 && ix < Ncore);
	for (n = v_names[ix]; n; lastn = n, n = n->nxt)	// mk_var
	{	if (n->h2 > h2)
		{	break;
		}
		if (n->h2 == h2
		&&  strcmp(n->nm, s) == 0)
		{	if (n->cdepth == Cdepth[ix])
			{	return n;	// found
			}
			if (n->cdepth == 0)
			{	g = n;
	}	}	}

	if (g)
	{	// printf("mk_var: global match %s depth %d\n", g->nm, g->cdepth);
		return g;	// global match
	}

	if (v_free[ix])
	{	n = v_free[ix];
		n->rtyp = n->v = 0;
		v_free[ix] = v_free[ix]->nxt;
		// n->pm may be pointing to a token from the actual
		// input sequence, which should not be reused
		if (!n->pm
		||   n->pm->seq != ISVAR)
		{	n->pm = (Prim *) hmalloc(sizeof(Prim), ix, 142);	// mk_var
		}
	} else
	{	n = (Var_nm *) hmalloc(sizeof(Var_nm), ix, 143);
		n->pm = (Prim *) hmalloc(sizeof(Prim), ix, 143);	// mk_var
	}

	n->pm->fnm = n->pm->txt = n->pm->typ = "";
	n->pm->len = 0;
	n->pm->seq = ISVAR;	// to identify origin
	n->nm = s;
	n->h2 = h2;
	n->rtyp = t;
	n->s  = "";
	n->cdepth = Cdepth[ix];

	if (lastn)
	{	n->nxt = lastn->nxt;
		lastn->nxt = n;
	} else
	{	n->nxt = v_names[ix];
		v_names[ix] = n;
	}
	return n;
}

void
rm_var(const char *s, int one, const int ix)
{	Var_nm *n, *nxt, *lst = (Var_nm *) 0;
	ulong h2 = hash2(s);

	assert(ix >= 0 && ix < Ncore);
	for (n = v_names[ix]; n; n = nxt)		// rm_var
	{	nxt = n->nxt;
		if (one && n->h2 > h2)
		{	break;
		}
		if ((one && n->h2 == h2 && strcmp(n->nm, s) == 0
			 && n->cdepth == Cdepth[ix])
		||  (!one && n->cdepth > Cdepth[ix]))
		{	if (lst)
			{	lst->nxt = nxt;
			} else
			{	v_names[ix] = nxt;
			}
			n->nxt = v_free[ix];
			v_free[ix]  = n;
		} else
		{	lst = n;
	}	}
}

static void
ini_vars(void)
{	static int vmax = 0;
	int i;

	if (Ncore > vmax)
	{	vmax = Ncore;
		v_names = (Var_nm **) 0;
		cstack  = (Cstack **) 0;
		Cdepth  = (int *)     0;
		t_stop  = (int *)     0;
	}
		
	if (!v_names)
	{	v_names = (Var_nm **) emalloc(NCORE * sizeof(Var_nm *), 84);
		v_free  = (Var_nm **) emalloc(NCORE * sizeof(Var_nm *), 84);
	}

	if (!cstack)
	{	cstack = (Cstack **) emalloc(NCORE * sizeof(Cstack *), 84);
		c_free = (Cstack **) emalloc(NCORE * sizeof(Cstack *), 84);
	}

	if (!Cdepth)
	{	Cdepth = (int *) emalloc(NCORE * sizeof(int), 84);
	}

	if (!t_stop)
	{	t_stop = (int *) emalloc(NCORE * sizeof(int), 84);
	}
	if (!sep)
	{	sep = (Separate *) emalloc(NCORE * sizeof(Separate), 84);
		for (i = 0; i < NCORE; i++)
		{	sep[i].Nest    = nest;
			sep[i].T_stop  = t_stop[i];
	}	}
	// the following can change during a run
	for (i = 0; i < NCORE; i++)
	{	sep[i].Verbose = verbose;
		sep[i].P_debug = p_debug;
	}
	ini_arrays();
	ini_lists();
}

static void
mk_varpool(void)
{	Var_nm *n;
	int i, k;

	// avoid having to call emalloc in mk_var
	// during multi-core program runs

	for (i = 0; i < Ncore; i++)
	{	k = v_cnt;
		for (n = v_free[i]; n; n = n->nxt)
		{	k--;
		}
		while (k-- >= 0)
		{	n = (Var_nm *) emalloc(sizeof(Var_nm), 85); // mk_varpool
			n->pm = &none;
			none.seq = NONE;	// to know source
			n->nxt = v_free[i];
			v_free[i] = n;
		}
		prepopulate(a_cnt, i);
	}
}

static void
ini_blocks(void)
{	Block *b;
	int have_blocks, i;
	static int maxb = 0;

	if (!block || Ncore > maxb)
	{	block  = (Block **) emalloc(NCORE * sizeof(Block *), 86);
		b_free = (Block **) emalloc(NCORE * sizeof(Block *), 86);
		if (Ncore > maxb)
		{	maxb = Ncore;
		}
	} else
	{	for (i = 0; i < Ncore; i++)
		{	while ((b = pop_context(i, 5)) != NULL)	// cleanup
			{	bfree(b, i);
				printf("recover block %d\n", i); // shouldnt happen
	}	}	}


	for (i = 0; i < Ncore; i++)
	{	have_blocks = 0;
		for (b = b_free[i]; b; b = b->nxt)
		{	have_blocks++;
		}
		while (have_blocks++ < n_blocks + 2)
		{	b = (Block *) emalloc(sizeof(Block), 87);
			bfree(b, i);
	}	}
}

#ifdef DUP_TREES
static unsigned long loc_copy;	// avoid sharing access to parse tree between cores

static void
clear_dup(void)	// when p_tree changes
{
	loc_copy = 0;
}

static Lextok *
dup_tree(Lextok *p)
{	Lextok *n;

	if (!p)
	{	return NULL;
	}
	if (p->visit & 32)
	{	return p;
	}
	p->visit |= 32;

	n = (Lextok *) emalloc(sizeof(Lextok), 88);
	memcpy(n, p, sizeof(Lextok));

	if (p->s)
	{	n->s = (char *) emalloc(strlen(p->s)+1, 89);
		strcpy(n->s, p->s);
	}

	n->a = dup_tree(p->a);
	n->b = dup_tree(p->b);
	n->c = dup_tree(p->c);
	n->core = dup_tree(p->core);

	// leave n->f as is

	n->lft = dup_tree(p->lft);
	n->rgt = dup_tree(p->rgt);

	return n;
}

static void
clr_marks(Lextok *p)
{
	if (!p || p->visit == 0)
	{	return;
	}
	p->visit = 0;
	clr_marks(p->a);
	clr_marks(p->b);
	clr_marks(p->c);
	clr_marks(p->core);
	clr_marks(p->lft);
	clr_marks(p->rgt);
}
#endif

// externally visible functions:

int
exec_prog(Prim **q, int ix)
{	Rtype rv;

	assert(ix >= 0 && ix < Ncore);
	sep[ix].T_stop = 0;
	memset(&rv, 0, sizeof(Rtype));

#ifdef DUP_TREES
	// reduce cache misses
	if (Ncore > 1 && ix > 0 && !(loc_copy & (1<<ix)))
	{	Lextok *tmp;
		do_lock(ix);
		tmp = dup_tree(p_tree);
		clr_marks(p_tree);
		p_tree = tmp;
		loc_copy |= (1<<ix);
	//	printf("%d Dups\n", ix);
		do_unlock(ix);
	}
#endif
	eval_prog(q, p_tree, &rv, ix);

	if (sep[ix].P_debug == 2)
	{	printf("===%d\n", rv.rtyp);
	}

	switch (rv.rtyp) {
	case STP:
		return -1;
	case PRCD:
		return -2;
	default:
		break;
	}

	return rv.val;
}

static int
streamable(Lextok *t)
{
	if (!stream_override
	&&  t
	&&  !(t->visit & 4))
	{	t->visit |= 4;
		switch (t->typ) {
#if 0
		case FIRST_T:
		case LAST_T:
		case BEGIN:
		case END:
#endif
		case PRV:
		case JMP:
		case N_CORE:
			fprintf(stderr, "script contains .jmp or .prv and is therefore not streamable:\n");
			show_error(stderr, t->lnr);
			return 0;
		case CALL:
			if (!streamable(t->c))
			{	return 0;
			}
		default:
			if (!streamable(t->lft)
			||  !streamable(t->rgt))
			{	return 0;
	}	}	}

	return 1;
}

int
prep_prog(FILE *nfd)
{	static int uniq = 0;	// parse time only

	pfd = nfd;		// prog_fd
	n_blocks = 1;
	p_lnr = 1;
	v_cnt = 0;

	ini_vars();

	sep[0].T_stop = 0;
	if (!xxparse() || sep[0].T_stop)
	{	fprintf(stderr, "[%d]\n", sep[0].T_stop);
		show_error(stderr, p_lnr);
		return 0;
	}

	mk_varpool();

	none.fnm = none.typ = none.txt = "";
	ini_blocks();

	if (preserve || p_debug == 3)
	{	FILE *x = fopen(CobraDot, "a");
		if (!x)
		{	printf("cannot create '%s'\n", CobraDot);
		} else
		{	fprintf(x, "digraph X%d {\n", uniq++);
			draw_ast(p_tree, x);
			fprintf(x, "}\n");
			fclose(x);
			if (preserve)
			{	printf("wrote: %s\n", CobraDot);
			}
			if (p_debug == 3 && system(ShowDot) < 0)
			{	perror(ShowDot);
			}
			sleep(1);
	}	}

	p_tree = fix_while(p_tree);			// visit |= 1
#ifdef DUP_TREES
	clear_dup();
#endif
	mk_fsm(p_tree, 0);				// visit |= 2
	opt_fsm(p_tree);				// visit |= 8
//	dump_tree(p_tree, 0);

	if (stream == 1
	&& !streamable(p_tree))
	{	return 0;
	}

	if (preserve || p_debug == 4)
	{	FILE *x = fopen(FsmDot, "a");
		if (!x)
		{	printf("cannot create '%s'\n", FsmDot);
		} else
		{	fprintf(x, "digraph X%d {\n", uniq++);
			draw_fsm(p_tree, x);		// visit |= 4
			fprintf(x, "}\n");
			fclose(x);
			if (preserve)
			{	printf("wrote: %s\n", FsmDot);
			}
			if (p_debug == 4 && system(ShowFsm) < 0)
			{	perror("ShowFsm");
			}
			sleep(1); // in case there's more than one
	}	}

	return 1;
}

void
stop_threads(void)
{	int i;

	for (i = 0; i < Ncore; i++)
	{	sep[i].T_stop++;
	}
}

int
has_stop_cmd(Lextok *p)
{
	if (!p || (p->visit & 128))
	{	return 0;
	}
	p->visit |= 128;
	if (p->typ == STOP)
	{	return p->lnr+1;
	}
	return	has_stop_cmd(p->lft)
	||	has_stop_cmd(p->rgt)
	||	has_stop_cmd(p->a)
	||	has_stop_cmd(p->b)
	||	has_stop_cmd(p->c);
}

int
has_stop(void)
{
	return has_stop_cmd(p_tree);
}
#line 6415 "cobra_prog.c"

/* For use in generated program */
#define yydepth (int)(yystack.s_mark - yystack.s_base)
#if YYBTYACC
#define yytrial (yyps->save)
#endif /* YYBTYACC */

#if YYDEBUG
#include <stdio.h>	/* needed for printf */
#endif

#include <stdlib.h>	/* needed for malloc, etc */
#include <string.h>	/* needed for memset */

/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack(YYSTACKDATA *data)
{
    int i;
    unsigned newsize;
    YYINT *newss;
    YYSTYPE *newvs;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
    YYLTYPE *newps;
#endif

    if ((newsize = data->stacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return YYENOMEM;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;

    i = (int) (data->s_mark - data->s_base);
    newss = (YYINT *)realloc(data->s_base, newsize * sizeof(*newss));
    if (newss == 0)
        return YYENOMEM;

    data->s_base = newss;
    data->s_mark = newss + i;

    newvs = (YYSTYPE *)realloc(data->l_base, newsize * sizeof(*newvs));
    if (newvs == 0)
        return YYENOMEM;

    data->l_base = newvs;
    data->l_mark = newvs + i;

#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
    newps = (YYLTYPE *)realloc(data->p_base, newsize * sizeof(*newps));
    if (newps == 0)
        return YYENOMEM;

    data->p_base = newps;
    data->p_mark = newps + i;
#endif

    data->stacksize = newsize;
    data->s_last = data->s_base + newsize - 1;

#if YYDEBUG
    if (yydebug)
        fprintf(stderr, "%sdebug: stack size increased to %d\n", YYPREFIX, newsize);
#endif
    return 0;
}

#if YYPURE || defined(YY_NO_LEAKS)
static void yyfreestack(YYSTACKDATA *data)
{
    free(data->s_base);
    free(data->l_base);
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
    free(data->p_base);
#endif
    memset(data, 0, sizeof(*data));
}
#else
#define yyfreestack(data) /* nothing */
#endif /* YYPURE || defined(YY_NO_LEAKS) */
#if YYBTYACC

static YYParseState *
yyNewState(unsigned size)
{
    YYParseState *p = (YYParseState *) malloc(sizeof(YYParseState));
    if (p == NULL) return NULL;

    p->yystack.stacksize = size;
    if (size == 0)
    {
        p->yystack.s_base = NULL;
        p->yystack.l_base = NULL;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
        p->yystack.p_base = NULL;
#endif
        return p;
    }
    p->yystack.s_base    = (YYINT *) malloc(size * sizeof(YYINT));
    if (p->yystack.s_base == NULL) return NULL;
    p->yystack.l_base    = (YYSTYPE *) malloc(size * sizeof(YYSTYPE));
    if (p->yystack.l_base == NULL) return NULL;
    memset(p->yystack.l_base, 0, size * sizeof(YYSTYPE));
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
    p->yystack.p_base    = (YYLTYPE *) malloc(size * sizeof(YYLTYPE));
    if (p->yystack.p_base == NULL) return NULL;
    memset(p->yystack.p_base, 0, size * sizeof(YYLTYPE));
#endif

    return p;
}

static void
yyFreeState(YYParseState *p)
{
    yyfreestack(&p->yystack);
    free(p);
}
#endif /* YYBTYACC */

#define YYABORT  goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR  goto yyerrlab
#if YYBTYACC
#define YYVALID        do { if (yyps->save)            goto yyvalid; } while(0)
#define YYVALID_NESTED do { if (yyps->save && \
                                yyps->save->save == 0) goto yyvalid; } while(0)
#endif /* YYBTYACC */

int
YYPARSE_DECL()
{
    int yym, yyn, yystate, yyresult;
#if YYBTYACC
    int yynewerrflag;
    YYParseState *yyerrctx = NULL;
#endif /* YYBTYACC */
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
    YYLTYPE  yyerror_loc_range[3]; /* position of error start/end (0 unused) */
#endif
#if YYDEBUG
    const char *yys;

    if ((yys = getenv("YYDEBUG")) != 0)
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
    if (yydebug)
        fprintf(stderr, "%sdebug[<# of symbols on state stack>]\n", YYPREFIX);
#endif
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
    memset(yyerror_loc_range, 0, sizeof(yyerror_loc_range));
#endif

#if YYBTYACC
    yyps = yyNewState(0); if (yyps == 0) goto yyenomem;
    yyps->save = 0;
#endif /* YYBTYACC */
    yym = 0;
    /* yyn is set below */
    yynerrs = 0;
    yyerrflag = 0;
    yychar = YYEMPTY;
    yystate = 0;

#if YYPURE
    memset(&yystack, 0, sizeof(yystack));
#endif

    if (yystack.s_base == NULL && yygrowstack(&yystack) == YYENOMEM) goto yyoverflow;
    yystack.s_mark = yystack.s_base;
    yystack.l_mark = yystack.l_base;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
    yystack.p_mark = yystack.p_base;
#endif
    yystate = 0;
    *yystack.s_mark = 0;

yyloop:
    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
    if (yychar < 0)
    {
#if YYBTYACC
        do {
        if (yylvp < yylve)
        {
            /* we're currently re-reading tokens */
            yylval = *yylvp++;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
            yylloc = *yylpp++;
#endif
            yychar = *yylexp++;
            break;
        }
        if (yyps->save)
        {
            /* in trial mode; save scanner results for future parse attempts */
            if (yylvp == yylvlim)
            {   /* Enlarge lexical value queue */
                size_t p = (size_t) (yylvp - yylvals);
                size_t s = (size_t) (yylvlim - yylvals);

                s += YYLVQUEUEGROWTH;
                if ((yylexemes = (YYINT *)realloc(yylexemes, s * sizeof(YYINT))) == NULL) goto yyenomem;
                if ((yylvals   = (YYSTYPE *)realloc(yylvals, s * sizeof(YYSTYPE))) == NULL) goto yyenomem;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                if ((yylpsns   = (YYLTYPE *)realloc(yylpsns, s * sizeof(YYLTYPE))) == NULL) goto yyenomem;
#endif
                yylvp   = yylve = yylvals + p;
                yylvlim = yylvals + s;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                yylpp   = yylpe = yylpsns + p;
                yylplim = yylpsns + s;
#endif
                yylexp  = yylexemes + p;
            }
            *yylexp = (YYINT) YYLEX;
            *yylvp++ = yylval;
            yylve++;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
            *yylpp++ = yylloc;
            yylpe++;
#endif
            yychar = *yylexp++;
            break;
        }
        /* normal operation, no conflict encountered */
#endif /* YYBTYACC */
        yychar = YYLEX;
#if YYBTYACC
        } while (0);
#endif /* YYBTYACC */
        if (yychar < 0) yychar = YYEOF;
#if YYDEBUG
        if (yydebug)
        {
            if ((yys = yyname[YYTRANSLATE(yychar)]) == NULL) yys = yyname[YYUNDFTOKEN];
            fprintf(stderr, "%s[%d]: state %d, reading token %d (%s)",
                            YYDEBUGSTR, yydepth, yystate, yychar, yys);
#ifdef YYSTYPE_TOSTRING
#if YYBTYACC
            if (!yytrial)
#endif /* YYBTYACC */
                fprintf(stderr, " <%s>", YYSTYPE_TOSTRING(yychar, yylval));
#endif
            fputc('\n', stderr);
        }
#endif
    }
#if YYBTYACC

    /* Do we have a conflict? */
    if (((yyn = yycindex[yystate]) != 0) && (yyn += yychar) >= 0 &&
        yyn <= YYTABLESIZE && yycheck[yyn] == (YYINT) yychar)
    {
        YYINT ctry;

        if (yypath)
        {
            YYParseState *save;
#if YYDEBUG
            if (yydebug)
                fprintf(stderr, "%s[%d]: CONFLICT in state %d: following successful trial parse\n",
                                YYDEBUGSTR, yydepth, yystate);
#endif
            /* Switch to the next conflict context */
            save = yypath;
            yypath = save->save;
            save->save = NULL;
            ctry = save->ctry;
            if (save->state != yystate) YYABORT;
            yyFreeState(save);

        }
        else
        {

            /* Unresolved conflict - start/continue trial parse */
            YYParseState *save;
#if YYDEBUG
            if (yydebug)
            {
                fprintf(stderr, "%s[%d]: CONFLICT in state %d. ", YYDEBUGSTR, yydepth, yystate);
                if (yyps->save)
                    fputs("ALREADY in conflict, continuing trial parse.\n", stderr);
                else
                    fputs("Starting trial parse.\n", stderr);
            }
#endif
            save                  = yyNewState((unsigned)(yystack.s_mark - yystack.s_base + 1));
            if (save == NULL) goto yyenomem;
            save->save            = yyps->save;
            save->state           = yystate;
            save->errflag         = yyerrflag;
            save->yystack.s_mark  = save->yystack.s_base + (yystack.s_mark - yystack.s_base);
            memcpy (save->yystack.s_base, yystack.s_base, (size_t) (yystack.s_mark - yystack.s_base + 1) * sizeof(YYINT));
            save->yystack.l_mark  = save->yystack.l_base + (yystack.l_mark - yystack.l_base);
            memcpy (save->yystack.l_base, yystack.l_base, (size_t) (yystack.l_mark - yystack.l_base + 1) * sizeof(YYSTYPE));
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
            save->yystack.p_mark  = save->yystack.p_base + (yystack.p_mark - yystack.p_base);
            memcpy (save->yystack.p_base, yystack.p_base, (size_t) (yystack.p_mark - yystack.p_base + 1) * sizeof(YYLTYPE));
#endif
            ctry                  = yytable[yyn];
            if (yyctable[ctry] == -1)
            {
#if YYDEBUG
                if (yydebug && yychar >= YYEOF)
                    fprintf(stderr, "%s[%d]: backtracking 1 token\n", YYDEBUGSTR, yydepth);
#endif
                ctry++;
            }
            save->ctry = ctry;
            if (yyps->save == NULL)
            {
                /* If this is a first conflict in the stack, start saving lexemes */
                if (!yylexemes)
                {
                    yylexemes = (YYINT *) malloc((YYLVQUEUEGROWTH) * sizeof(YYINT));
                    if (yylexemes == NULL) goto yyenomem;
                    yylvals   = (YYSTYPE *) malloc((YYLVQUEUEGROWTH) * sizeof(YYSTYPE));
                    if (yylvals == NULL) goto yyenomem;
                    yylvlim   = yylvals + YYLVQUEUEGROWTH;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                    yylpsns   = (YYLTYPE *) malloc((YYLVQUEUEGROWTH) * sizeof(YYLTYPE));
                    if (yylpsns == NULL) goto yyenomem;
                    yylplim   = yylpsns + YYLVQUEUEGROWTH;
#endif
                }
                if (yylvp == yylve)
                {
                    yylvp  = yylve = yylvals;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                    yylpp  = yylpe = yylpsns;
#endif
                    yylexp = yylexemes;
                    if (yychar >= YYEOF)
                    {
                        *yylve++ = yylval;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                        *yylpe++ = yylloc;
#endif
                        *yylexp  = (YYINT) yychar;
                        yychar   = YYEMPTY;
                    }
                }
            }
            if (yychar >= YYEOF)
            {
                yylvp--;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                yylpp--;
#endif
                yylexp--;
                yychar = YYEMPTY;
            }
            save->lexeme = (int) (yylvp - yylvals);
            yyps->save   = save;
        }
        if (yytable[yyn] == ctry)
        {
#if YYDEBUG
            if (yydebug)
                fprintf(stderr, "%s[%d]: state %d, shifting to state %d\n",
                                YYDEBUGSTR, yydepth, yystate, yyctable[ctry]);
#endif
            if (yychar < 0)
            {
                yylvp++;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                yylpp++;
#endif
                yylexp++;
            }
            if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
                goto yyoverflow;
            yystate = yyctable[ctry];
            *++yystack.s_mark = (YYINT) yystate;
            *++yystack.l_mark = yylval;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
            *++yystack.p_mark = yylloc;
#endif
            yychar  = YYEMPTY;
            if (yyerrflag > 0) --yyerrflag;
            goto yyloop;
        }
        else
        {
            yyn = yyctable[ctry];
            goto yyreduce;
        }
    } /* End of code dealing with conflicts */
#endif /* YYBTYACC */
    if (((yyn = yysindex[yystate]) != 0) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == (YYINT) yychar)
    {
#if YYDEBUG
        if (yydebug)
            fprintf(stderr, "%s[%d]: state %d, shifting to state %d\n",
                            YYDEBUGSTR, yydepth, yystate, yytable[yyn]);
#endif
        if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM) goto yyoverflow;
        yystate = yytable[yyn];
        *++yystack.s_mark = yytable[yyn];
        *++yystack.l_mark = yylval;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
        *++yystack.p_mark = yylloc;
#endif
        yychar = YYEMPTY;
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if (((yyn = yyrindex[yystate]) != 0) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == (YYINT) yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag != 0) goto yyinrecovery;
#if YYBTYACC

    yynewerrflag = 1;
    goto yyerrhandler;
    goto yyerrlab; /* redundant goto avoids 'unused label' warning */

yyerrlab:
    /* explicit YYERROR from an action -- pop the rhs of the rule reduced
     * before looking for error recovery */
    yystack.s_mark -= yym;
    yystate = *yystack.s_mark;
    yystack.l_mark -= yym;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
    yystack.p_mark -= yym;
#endif

    yynewerrflag = 0;
yyerrhandler:
    while (yyps->save)
    {
        int ctry;
        YYParseState *save = yyps->save;
#if YYDEBUG
        if (yydebug)
            fprintf(stderr, "%s[%d]: ERROR in state %d, CONFLICT BACKTRACKING to state %d, %d tokens\n",
                            YYDEBUGSTR, yydepth, yystate, yyps->save->state,
                    (int)(yylvp - yylvals - yyps->save->lexeme));
#endif
        /* Memorize most forward-looking error state in case it's really an error. */
        if (yyerrctx == NULL || yyerrctx->lexeme < yylvp - yylvals)
        {
            /* Free old saved error context state */
            if (yyerrctx) yyFreeState(yyerrctx);
            /* Create and fill out new saved error context state */
            yyerrctx                 = yyNewState((unsigned)(yystack.s_mark - yystack.s_base + 1));
            if (yyerrctx == NULL) goto yyenomem;
            yyerrctx->save           = yyps->save;
            yyerrctx->state          = yystate;
            yyerrctx->errflag        = yyerrflag;
            yyerrctx->yystack.s_mark = yyerrctx->yystack.s_base + (yystack.s_mark - yystack.s_base);
            memcpy (yyerrctx->yystack.s_base, yystack.s_base, (size_t) (yystack.s_mark - yystack.s_base + 1) * sizeof(YYINT));
            yyerrctx->yystack.l_mark = yyerrctx->yystack.l_base + (yystack.l_mark - yystack.l_base);
            memcpy (yyerrctx->yystack.l_base, yystack.l_base, (size_t) (yystack.l_mark - yystack.l_base + 1) * sizeof(YYSTYPE));
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
            yyerrctx->yystack.p_mark = yyerrctx->yystack.p_base + (yystack.p_mark - yystack.p_base);
            memcpy (yyerrctx->yystack.p_base, yystack.p_base, (size_t) (yystack.p_mark - yystack.p_base + 1) * sizeof(YYLTYPE));
#endif
            yyerrctx->lexeme         = (int) (yylvp - yylvals);
        }
        yylvp          = yylvals   + save->lexeme;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
        yylpp          = yylpsns   + save->lexeme;
#endif
        yylexp         = yylexemes + save->lexeme;
        yychar         = YYEMPTY;
        yystack.s_mark = yystack.s_base + (save->yystack.s_mark - save->yystack.s_base);
        memcpy (yystack.s_base, save->yystack.s_base, (size_t) (yystack.s_mark - yystack.s_base + 1) * sizeof(YYINT));
        yystack.l_mark = yystack.l_base + (save->yystack.l_mark - save->yystack.l_base);
        memcpy (yystack.l_base, save->yystack.l_base, (size_t) (yystack.l_mark - yystack.l_base + 1) * sizeof(YYSTYPE));
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
        yystack.p_mark = yystack.p_base + (save->yystack.p_mark - save->yystack.p_base);
        memcpy (yystack.p_base, save->yystack.p_base, (size_t) (yystack.p_mark - yystack.p_base + 1) * sizeof(YYLTYPE));
#endif
        ctry           = ++save->ctry;
        yystate        = save->state;
        /* We tried shift, try reduce now */
        if ((yyn = yyctable[ctry]) >= 0) goto yyreduce;
        yyps->save     = save->save;
        save->save     = NULL;
        yyFreeState(save);

        /* Nothing left on the stack -- error */
        if (!yyps->save)
        {
#if YYDEBUG
            if (yydebug)
                fprintf(stderr, "%sdebug[%d,trial]: trial parse FAILED, entering ERROR mode\n",
                                YYPREFIX, yydepth);
#endif
            /* Restore state as it was in the most forward-advanced error */
            yylvp          = yylvals   + yyerrctx->lexeme;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
            yylpp          = yylpsns   + yyerrctx->lexeme;
#endif
            yylexp         = yylexemes + yyerrctx->lexeme;
            yychar         = yylexp[-1];
            yylval         = yylvp[-1];
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
            yylloc         = yylpp[-1];
#endif
            yystack.s_mark = yystack.s_base + (yyerrctx->yystack.s_mark - yyerrctx->yystack.s_base);
            memcpy (yystack.s_base, yyerrctx->yystack.s_base, (size_t) (yystack.s_mark - yystack.s_base + 1) * sizeof(YYINT));
            yystack.l_mark = yystack.l_base + (yyerrctx->yystack.l_mark - yyerrctx->yystack.l_base);
            memcpy (yystack.l_base, yyerrctx->yystack.l_base, (size_t) (yystack.l_mark - yystack.l_base + 1) * sizeof(YYSTYPE));
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
            yystack.p_mark = yystack.p_base + (yyerrctx->yystack.p_mark - yyerrctx->yystack.p_base);
            memcpy (yystack.p_base, yyerrctx->yystack.p_base, (size_t) (yystack.p_mark - yystack.p_base + 1) * sizeof(YYLTYPE));
#endif
            yystate        = yyerrctx->state;
            yyFreeState(yyerrctx);
            yyerrctx       = NULL;
        }
        yynewerrflag = 1;
    }
    if (yynewerrflag == 0) goto yyinrecovery;
#endif /* YYBTYACC */

    YYERROR_CALL("syntax error");
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
    yyerror_loc_range[1] = yylloc; /* lookahead position is error start position */
#endif

#if !YYBTYACC
    goto yyerrlab; /* redundant goto avoids 'unused label' warning */
yyerrlab:
#endif
    ++yynerrs;

yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if (((yyn = yysindex[*yystack.s_mark]) != 0) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == (YYINT) YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    fprintf(stderr, "%s[%d]: state %d, error recovery shifting to state %d\n",
                                    YYDEBUGSTR, yydepth, *yystack.s_mark, yytable[yyn]);
#endif
                if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM) goto yyoverflow;
                yystate = yytable[yyn];
                *++yystack.s_mark = yytable[yyn];
                *++yystack.l_mark = yylval;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                /* lookahead position is error end position */
                yyerror_loc_range[2] = yylloc;
                YYLLOC_DEFAULT(yyloc, yyerror_loc_range, 2); /* position of error span */
                *++yystack.p_mark = yyloc;
#endif
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    fprintf(stderr, "%s[%d]: error recovery discarding state %d\n",
                                    YYDEBUGSTR, yydepth, *yystack.s_mark);
#endif
                if (yystack.s_mark <= yystack.s_base) goto yyabort;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                /* the current TOS position is the error start position */
                yyerror_loc_range[1] = *yystack.p_mark;
#endif
#if defined(YYDESTRUCT_CALL)
#if YYBTYACC
                if (!yytrial)
#endif /* YYBTYACC */
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                    YYDESTRUCT_CALL("error: discarding state",
                                    yystos[*yystack.s_mark], yystack.l_mark, yystack.p_mark);
#else
                    YYDESTRUCT_CALL("error: discarding state",
                                    yystos[*yystack.s_mark], yystack.l_mark);
#endif /* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */
#endif /* defined(YYDESTRUCT_CALL) */
                --yystack.s_mark;
                --yystack.l_mark;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                --yystack.p_mark;
#endif
            }
        }
    }
    else
    {
        if (yychar == YYEOF) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            if ((yys = yyname[YYTRANSLATE(yychar)]) == NULL) yys = yyname[YYUNDFTOKEN];
            fprintf(stderr, "%s[%d]: state %d, error recovery discarding token %d (%s)\n",
                            YYDEBUGSTR, yydepth, yystate, yychar, yys);
        }
#endif
#if defined(YYDESTRUCT_CALL)
#if YYBTYACC
        if (!yytrial)
#endif /* YYBTYACC */
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
            YYDESTRUCT_CALL("error: discarding token", yychar, &yylval, &yylloc);
#else
            YYDESTRUCT_CALL("error: discarding token", yychar, &yylval);
#endif /* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */
#endif /* defined(YYDESTRUCT_CALL) */
        yychar = YYEMPTY;
        goto yyloop;
    }

yyreduce:
    yym = yylen[yyn];
#if YYDEBUG
    if (yydebug)
    {
        fprintf(stderr, "%s[%d]: state %d, reducing by rule %d (%s)",
                        YYDEBUGSTR, yydepth, yystate, yyn, yyrule[yyn]);
#ifdef YYSTYPE_TOSTRING
#if YYBTYACC
        if (!yytrial)
#endif /* YYBTYACC */
            if (yym > 0)
            {
                int i;
                fputc('<', stderr);
                for (i = yym; i > 0; i--)
                {
                    if (i != yym) fputs(", ", stderr);
                    fputs(YYSTYPE_TOSTRING(yystos[yystack.s_mark[1-i]],
                                           yystack.l_mark[1-i]), stderr);
                }
                fputc('>', stderr);
            }
#endif
        fputc('\n', stderr);
    }
#endif
    if (yym > 0)
        yyval = yystack.l_mark[1-yym];
    else
        memset(&yyval, 0, sizeof yyval);
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)

    /* Perform position reduction */
    memset(&yyloc, 0, sizeof(yyloc));
#if YYBTYACC
    if (!yytrial)
#endif /* YYBTYACC */
    {
        YYLLOC_DEFAULT(yyloc, &yystack.p_mark[-yym], yym);
        /* just in case YYERROR is invoked within the action, save
           the start of the rhs as the error start position */
        yyerror_loc_range[1] = yystack.p_mark[1-yym];
    }
#endif

    switch (yyn)
    {
case 1:
#line 174 "cobra_prog.y"
	{ p_tree = yystack.l_mark[0]; return 1; }
#line 7088 "cobra_prog.c"
break;
case 2:
#line 176 "cobra_prog.y"
	{ yyval = yystack.l_mark[-1];  }
#line 7093 "cobra_prog.c"
break;
case 3:
#line 178 "cobra_prog.y"
	{ yyval = yystack.l_mark[0]; }
#line 7098 "cobra_prog.c"
break;
case 4:
#line 179 "cobra_prog.y"
	{ yyval = new_lex(';', yystack.l_mark[-1], yystack.l_mark[0]);
			   n_blocks++;
			   if (yystack.l_mark[-1]->typ == CALL
			   ||  yystack.l_mark[-1]->typ == FUNCTION)
			   {	yystack.l_mark[-1]->c = yystack.l_mark[0];
			   }
			 }
#line 7109 "cobra_prog.c"
break;
case 5:
#line 187 "cobra_prog.y"
	{
			   yystack.l_mark[-5]->lft = yystack.l_mark[-3];	/* cond*/
			   yystack.l_mark[-5]->rgt = new_lex(0, yystack.l_mark[-1], yystack.l_mark[0]);
			   yystack.l_mark[-5]->lnr = p_lnr;
			   yyval = yystack.l_mark[-5]; }
#line 7118 "cobra_prog.c"
break;
case 6:
#line 192 "cobra_prog.y"
	{
			   yystack.l_mark[-4]->lft = yystack.l_mark[-2];	/* cond*/
			   yystack.l_mark[-4]->rgt = yystack.l_mark[0];	/* body*/
			   n_blocks++;
			   yyval = yystack.l_mark[-4]; }
#line 7127 "cobra_prog.c"
break;
case 7:
#line 197 "cobra_prog.y"
	{
			   n_blocks++; v_cnt++; a_cnt++;
			   yyval = mk_for(yystack.l_mark[-6], yystack.l_mark[-4], yystack.l_mark[-2], yystack.l_mark[0]); }
#line 7134 "cobra_prog.c"
break;
case 8:
#line 200 "cobra_prog.y"
	{
			   yystack.l_mark[-5]->lft = new_lex(0, yystack.l_mark[-4], yystack.l_mark[-2]);

			   if ((!yystack.l_mark[0]->rgt || !yystack.l_mark[0]->rgt->typ)
			   &&   yystack.l_mark[0]->typ != RETURN)
			   {	yystack.l_mark[-5]->rgt = new_lex(';', yystack.l_mark[0], new_lex(RETURN, 0, 0));
			   } else
			   {	if (yystack.l_mark[0]->typ != WHILE)
				{	yystack.l_mark[-5]->rgt = add_return(yystack.l_mark[0]);
				} else /* fixed after fix_while in find_fct*/
				{	yystack.l_mark[-5]->rgt = yystack.l_mark[0];
			   }	}

			   add_fct(yystack.l_mark[-5]);
			   n_blocks++;
			   yyval = yystack.l_mark[-5];
			}
#line 7155 "cobra_prog.c"
break;
case 9:
#line 217 "cobra_prog.y"
	{ v_cnt++; mk_lab(yystack.l_mark[-2], yystack.l_mark[0]); yyval = yystack.l_mark[0]; }
#line 7160 "cobra_prog.c"
break;
case 11:
#line 220 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7165 "cobra_prog.c"
break;
case 12:
#line 221 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-4]; yystack.l_mark[-3]->rgt = yystack.l_mark[-2]; yyval = yystack.l_mark[-3]; }
#line 7170 "cobra_prog.c"
break;
case 13:
#line 222 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-3]; }
#line 7175 "cobra_prog.c"
break;
case 14:
#line 223 "cobra_prog.y"
	{
				yystack.l_mark[-7]->lft = new_lex(0, yystack.l_mark[-5], yystack.l_mark[-3]);
				yystack.l_mark[-7]->rgt = yystack.l_mark[-1];
				yyval = yystack.l_mark[-7];
			}
#line 7184 "cobra_prog.c"
break;
case 15:
#line 228 "cobra_prog.y"
	{ yyval = yystack.l_mark[-1]; handle_global(yystack.l_mark[0]); }
#line 7189 "cobra_prog.c"
break;
case 16:
#line 229 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7194 "cobra_prog.c"
break;
case 17:
#line 230 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7199 "cobra_prog.c"
break;
case 18:
#line 231 "cobra_prog.y"
	{
			   yystack.l_mark[-4]->lft = yystack.l_mark[-3];
			   yystack.l_mark[-4]->rgt = yystack.l_mark[-1];
			   yyval = yystack.l_mark[-4];
			}
#line 7208 "cobra_prog.c"
break;
case 19:
#line 236 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7213 "cobra_prog.c"
break;
case 20:
#line 237 "cobra_prog.y"
	{ yyval = yystack.l_mark[-2]; }
#line 7218 "cobra_prog.c"
break;
case 21:
#line 238 "cobra_prog.y"
	{ yyval = yystack.l_mark[-2]; }
#line 7223 "cobra_prog.c"
break;
case 22:
#line 239 "cobra_prog.y"
	{ yystack.l_mark[-5]->lft = yystack.l_mark[-3]; yystack.l_mark[-5]->rgt = yystack.l_mark[-1]; yyval = yystack.l_mark[-5]; }
#line 7228 "cobra_prog.c"
break;
case 23:
#line 240 "cobra_prog.y"
	{ yystack.l_mark[-5]->lft = yystack.l_mark[-3]; yystack.l_mark[-5]->rgt = yystack.l_mark[-1]; yyval = yystack.l_mark[-5]; }
#line 7233 "cobra_prog.c"
break;
case 24:
#line 241 "cobra_prog.y"
	{ yyval = yystack.l_mark[-2]; }
#line 7238 "cobra_prog.c"
break;
case 25:
#line 242 "cobra_prog.y"
	{ yyval = yystack.l_mark[-2]; }
#line 7243 "cobra_prog.c"
break;
case 26:
#line 243 "cobra_prog.y"
	{ yyval = new_lex(CALL, yystack.l_mark[-3], yystack.l_mark[-1]); }
#line 7248 "cobra_prog.c"
break;
case 27:
#line 244 "cobra_prog.y"
	{ yystack.l_mark[0]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[0]; }
#line 7253 "cobra_prog.c"
break;
case 28:
#line 245 "cobra_prog.y"
	{ yystack.l_mark[0]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[0]; }
#line 7258 "cobra_prog.c"
break;
case 29:
#line 246 "cobra_prog.y"
	{ yystack.l_mark[-5]->lft = yystack.l_mark[-3]; yystack.l_mark[-5]->rgt = yystack.l_mark[-1]; yyval = yystack.l_mark[-5]; }
#line 7263 "cobra_prog.c"
break;
case 30:
#line 247 "cobra_prog.y"
	{ yystack.l_mark[-5]->lft = yystack.l_mark[-1]; yystack.l_mark[-5]->rgt = yystack.l_mark[-3]; yyval = yystack.l_mark[-5]; }
#line 7268 "cobra_prog.c"
break;
case 31:
#line 248 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yystack.l_mark[-3]->rgt = 0; yyval = yystack.l_mark[-3]; }
#line 7273 "cobra_prog.c"
break;
case 32:
#line 250 "cobra_prog.y"
	{
				yystack.l_mark[-7]->lft = yystack.l_mark[-5];
				yystack.l_mark[-7]->rgt = new_lex(0, yystack.l_mark[-3], yystack.l_mark[-1]);
				yyval = yystack.l_mark[-7];
			}
#line 7282 "cobra_prog.c"
break;
case 33:
#line 255 "cobra_prog.y"
	{
				yystack.l_mark[-7]->lft = yystack.l_mark[-5];
				yystack.l_mark[-7]->rgt = new_lex(0, yystack.l_mark[-3], yystack.l_mark[-1]);
				yyval = yystack.l_mark[-7];
			}
#line 7291 "cobra_prog.c"
break;
case 34:
#line 261 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-3];}
#line 7296 "cobra_prog.c"
break;
case 35:
#line 262 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-3];}
#line 7301 "cobra_prog.c"
break;
case 36:
#line 263 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-3];}
#line 7306 "cobra_prog.c"
break;
case 37:
#line 264 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-3];}
#line 7311 "cobra_prog.c"
break;
case 38:
#line 265 "cobra_prog.y"
	{ yystack.l_mark[-5]->lft = yystack.l_mark[-3]; yystack.l_mark[-5]->rgt = yystack.l_mark[-1]; yyval = yystack.l_mark[-5]; }
#line 7316 "cobra_prog.c"
break;
case 39:
#line 266 "cobra_prog.y"
	{ yystack.l_mark[-5]->lft = yystack.l_mark[-3]; yystack.l_mark[-5]->rgt = yystack.l_mark[-1]; yyval = yystack.l_mark[-5]; }
#line 7321 "cobra_prog.c"
break;
case 40:
#line 268 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7326 "cobra_prog.c"
break;
case 51:
#line 282 "cobra_prog.y"
	{ yyval =  0; }
#line 7331 "cobra_prog.c"
break;
case 53:
#line 285 "cobra_prog.y"
	{ yyval = 0; }
#line 7336 "cobra_prog.c"
break;
case 56:
#line 290 "cobra_prog.y"
	{ yyval = yystack.l_mark[-2]; yyval->rgt = yystack.l_mark[-1]; }
#line 7341 "cobra_prog.c"
break;
case 58:
#line 293 "cobra_prog.y"
	{ yyval = yystack.l_mark[-1]; yyval->lft = yystack.l_mark[-2]; yyval->rgt = yystack.l_mark[0]; }
#line 7346 "cobra_prog.c"
break;
case 60:
#line 297 "cobra_prog.y"
	{ yyval = yystack.l_mark[-1]; yyval->lft = yystack.l_mark[-2]; yyval->rgt = yystack.l_mark[0]; v_cnt++; }
#line 7351 "cobra_prog.c"
break;
case 61:
#line 300 "cobra_prog.y"
	{ yyval = 0; }
#line 7356 "cobra_prog.c"
break;
case 62:
#line 301 "cobra_prog.y"
	{ yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7361 "cobra_prog.c"
break;
case 64:
#line 305 "cobra_prog.y"
	{ yyval = new_lex(ARG, yystack.l_mark[-1], yystack.l_mark[0]); }
#line 7366 "cobra_prog.c"
break;
case 65:
#line 308 "cobra_prog.y"
	{ yyval = yystack.l_mark[0]; v_cnt++; }
#line 7371 "cobra_prog.c"
break;
case 66:
#line 309 "cobra_prog.y"
	{ yystack.l_mark[-2]->lft = yystack.l_mark[-3]; yystack.l_mark[-2]->rgt = yystack.l_mark[-1]; yyval = yystack.l_mark[-2]; a_cnt++; }
#line 7376 "cobra_prog.c"
break;
case 67:
#line 312 "cobra_prog.y"
	{ yyval = yystack.l_mark[-1]; }
#line 7381 "cobra_prog.c"
break;
case 68:
#line 313 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7386 "cobra_prog.c"
break;
case 69:
#line 314 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7391 "cobra_prog.c"
break;
case 70:
#line 315 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7396 "cobra_prog.c"
break;
case 71:
#line 316 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7401 "cobra_prog.c"
break;
case 72:
#line 317 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7406 "cobra_prog.c"
break;
case 73:
#line 318 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7411 "cobra_prog.c"
break;
case 74:
#line 319 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7416 "cobra_prog.c"
break;
case 75:
#line 320 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7421 "cobra_prog.c"
break;
case 76:
#line 321 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7426 "cobra_prog.c"
break;
case 77:
#line 322 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7431 "cobra_prog.c"
break;
case 78:
#line 323 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7436 "cobra_prog.c"
break;
case 79:
#line 324 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7441 "cobra_prog.c"
break;
case 80:
#line 325 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7446 "cobra_prog.c"
break;
case 81:
#line 326 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7451 "cobra_prog.c"
break;
case 82:
#line 327 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7456 "cobra_prog.c"
break;
case 83:
#line 328 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yystack.l_mark[-1]->typ = B_XOR; yyval = yystack.l_mark[-1]; }
#line 7461 "cobra_prog.c"
break;
case 84:
#line 329 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7466 "cobra_prog.c"
break;
case 85:
#line 330 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7471 "cobra_prog.c"
break;
case 86:
#line 331 "cobra_prog.y"
	{ yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7476 "cobra_prog.c"
break;
case 87:
#line 332 "cobra_prog.y"
	{ yystack.l_mark[-1]->typ = UMIN; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7481 "cobra_prog.c"
break;
case 88:
#line 333 "cobra_prog.y"
	{ yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7486 "cobra_prog.c"
break;
case 89:
#line 334 "cobra_prog.y"
	{ yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7491 "cobra_prog.c"
break;
case 90:
#line 335 "cobra_prog.y"
	{ fixstr(yystack.l_mark[0]); yyval = yystack.l_mark[0]; }
#line 7496 "cobra_prog.c"
break;
case 91:
#line 336 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-3]; }
#line 7501 "cobra_prog.c"
break;
case 92:
#line 337 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-3]; }
#line 7506 "cobra_prog.c"
break;
case 93:
#line 338 "cobra_prog.y"
	{ yystack.l_mark[-5]->lft = yystack.l_mark[-3]; yyval->rgt = yystack.l_mark[-1]; yyval = yystack.l_mark[-5]; }
#line 7511 "cobra_prog.c"
break;
case 94:
#line 339 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-3]; }
#line 7516 "cobra_prog.c"
break;
case 95:
#line 340 "cobra_prog.y"
	{
				  yystack.l_mark[-7]->lft = yystack.l_mark[-5];
				  yystack.l_mark[-7]->rgt = new_lex(0, yystack.l_mark[-3], yystack.l_mark[-1]);
				  yyval = yystack.l_mark[-7];
				}
#line 7525 "cobra_prog.c"
break;
case 96:
#line 345 "cobra_prog.y"
	{ yystack.l_mark[-5]->lft = yystack.l_mark[-3]; yystack.l_mark[-5]->rgt = yystack.l_mark[-1]; yystack.l_mark[-5]->s = ",";   yyval = yystack.l_mark[-5]; }
#line 7530 "cobra_prog.c"
break;
case 97:
#line 346 "cobra_prog.y"
	{ yystack.l_mark[-7]->lft = yystack.l_mark[-5]; yystack.l_mark[-7]->rgt = yystack.l_mark[-1]; yystack.l_mark[-7]->s = yystack.l_mark[-3]->s; yyval = yystack.l_mark[-7]; }
#line 7535 "cobra_prog.c"
break;
case 98:
#line 347 "cobra_prog.y"
	{ yystack.l_mark[-5]->lft = yystack.l_mark[-3]; yystack.l_mark[-5]->rgt =  0; yystack.l_mark[-5]->s = yystack.l_mark[-1]->s; yyval = yystack.l_mark[-5];  }
#line 7540 "cobra_prog.c"
break;
case 99:
#line 348 "cobra_prog.y"
	{ yystack.l_mark[-5]->lft = yystack.l_mark[-3]; yystack.l_mark[-5]->rgt =  0; yystack.l_mark[-5]->s = yystack.l_mark[-1]->s; yyval = yystack.l_mark[-5];  }
#line 7545 "cobra_prog.c"
break;
case 100:
#line 349 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-3];}
#line 7550 "cobra_prog.c"
break;
case 101:
#line 350 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-3]; }
#line 7555 "cobra_prog.c"
break;
case 102:
#line 351 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-3]; }
#line 7560 "cobra_prog.c"
break;
case 103:
#line 352 "cobra_prog.y"
	{ yyval = yystack.l_mark[-2]; }
#line 7565 "cobra_prog.c"
break;
case 104:
#line 353 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-3]; }
#line 7570 "cobra_prog.c"
break;
case 105:
#line 354 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-3]; }
#line 7575 "cobra_prog.c"
break;
case 106:
#line 355 "cobra_prog.y"
	{ yystack.l_mark[-3]->rgt = yystack.l_mark[-1]; yyval = yystack.l_mark[-3]; }
#line 7580 "cobra_prog.c"
break;
case 107:
#line 356 "cobra_prog.y"
	{ yystack.l_mark[-3]->rgt = yystack.l_mark[-1]; yyval = yystack.l_mark[-3]; }
#line 7585 "cobra_prog.c"
break;
case 108:
#line 357 "cobra_prog.y"
	{ yystack.l_mark[-5]->rgt = yystack.l_mark[-3]; yystack.l_mark[-5]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-5]; }
#line 7590 "cobra_prog.c"
break;
case 109:
#line 358 "cobra_prog.y"
	{ yystack.l_mark[-5]->lft = yystack.l_mark[-3]; yystack.l_mark[-5]->rgt = yystack.l_mark[-1]; yyval = yystack.l_mark[-5]; }
#line 7595 "cobra_prog.c"
break;
case 110:
#line 359 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = 0; yystack.l_mark[-3]->rgt = yystack.l_mark[-1]; yyval = yystack.l_mark[-3]; }
#line 7600 "cobra_prog.c"
break;
case 111:
#line 360 "cobra_prog.y"
	{ yystack.l_mark[-3]->lft = yystack.l_mark[-1]; yyval = yystack.l_mark[-3]; }
#line 7605 "cobra_prog.c"
break;
case 112:
#line 361 "cobra_prog.y"
	{ yystack.l_mark[-3]->rgt = yystack.l_mark[-1]; yyval = yystack.l_mark[-3]; }
#line 7610 "cobra_prog.c"
break;
case 113:
#line 362 "cobra_prog.y"
	{ yyval = new_lex(CALL, yystack.l_mark[-3], yystack.l_mark[-1]); }
#line 7615 "cobra_prog.c"
break;
case 114:
#line 363 "cobra_prog.y"
	{ yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7620 "cobra_prog.c"
break;
case 115:
#line 364 "cobra_prog.y"
	{ yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7625 "cobra_prog.c"
break;
case 116:
#line 365 "cobra_prog.y"
	{ yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7630 "cobra_prog.c"
break;
case 117:
#line 366 "cobra_prog.y"
	{ yystack.l_mark[-2]->core = yystack.l_mark[0]; yyval = yystack.l_mark[-2]; /* qualified name */ }
#line 7635 "cobra_prog.c"
break;
case 118:
#line 367 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; v_cnt++; }
#line 7640 "cobra_prog.c"
break;
case 129:
#line 379 "cobra_prog.y"
	{ yyval = new_lex(NAME, 0, 0); yyval->s = "*"; }
#line 7645 "cobra_prog.c"
break;
case 134:
#line 386 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft = yystack.l_mark[-2]; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; v_cnt++; }
#line 7650 "cobra_prog.c"
break;
case 135:
#line 387 "cobra_prog.y"
	{ yystack.l_mark[-1]->lft =  0; yystack.l_mark[-1]->rgt = yystack.l_mark[0]; yyval = yystack.l_mark[-1]; }
#line 7655 "cobra_prog.c"
break;
case 139:
#line 392 "cobra_prog.y"
	{ yyval = yystack.l_mark[-1]; yyval->lft = yystack.l_mark[-2]; yyval->rgt = yystack.l_mark[0]; }
#line 7660 "cobra_prog.c"
break;
#line 7662 "cobra_prog.c"
    default:
        break;
    }
    yystack.s_mark -= yym;
    yystate = *yystack.s_mark;
    yystack.l_mark -= yym;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
    yystack.p_mark -= yym;
#endif
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
        {
            fprintf(stderr, "%s[%d]: after reduction, ", YYDEBUGSTR, yydepth);
#ifdef YYSTYPE_TOSTRING
#if YYBTYACC
            if (!yytrial)
#endif /* YYBTYACC */
                fprintf(stderr, "result is <%s>, ", YYSTYPE_TOSTRING(yystos[YYFINAL], yyval));
#endif
            fprintf(stderr, "shifting from state 0 to final state %d\n", YYFINAL);
        }
#endif
        yystate = YYFINAL;
        *++yystack.s_mark = YYFINAL;
        *++yystack.l_mark = yyval;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
        *++yystack.p_mark = yyloc;
#endif
        if (yychar < 0)
        {
#if YYBTYACC
            do {
            if (yylvp < yylve)
            {
                /* we're currently re-reading tokens */
                yylval = *yylvp++;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                yylloc = *yylpp++;
#endif
                yychar = *yylexp++;
                break;
            }
            if (yyps->save)
            {
                /* in trial mode; save scanner results for future parse attempts */
                if (yylvp == yylvlim)
                {   /* Enlarge lexical value queue */
                    size_t p = (size_t) (yylvp - yylvals);
                    size_t s = (size_t) (yylvlim - yylvals);

                    s += YYLVQUEUEGROWTH;
                    if ((yylexemes = (YYINT *)realloc(yylexemes, s * sizeof(YYINT))) == NULL)
                        goto yyenomem;
                    if ((yylvals   = (YYSTYPE *)realloc(yylvals, s * sizeof(YYSTYPE))) == NULL)
                        goto yyenomem;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                    if ((yylpsns   = (YYLTYPE *)realloc(yylpsns, s * sizeof(YYLTYPE))) == NULL)
                        goto yyenomem;
#endif
                    yylvp   = yylve = yylvals + p;
                    yylvlim = yylvals + s;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                    yylpp   = yylpe = yylpsns + p;
                    yylplim = yylpsns + s;
#endif
                    yylexp  = yylexemes + p;
                }
                *yylexp = (YYINT) YYLEX;
                *yylvp++ = yylval;
                yylve++;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
                *yylpp++ = yylloc;
                yylpe++;
#endif
                yychar = *yylexp++;
                break;
            }
            /* normal operation, no conflict encountered */
#endif /* YYBTYACC */
            yychar = YYLEX;
#if YYBTYACC
            } while (0);
#endif /* YYBTYACC */
            if (yychar < 0) yychar = YYEOF;
#if YYDEBUG
            if (yydebug)
            {
                if ((yys = yyname[YYTRANSLATE(yychar)]) == NULL) yys = yyname[YYUNDFTOKEN];
                fprintf(stderr, "%s[%d]: state %d, reading token %d (%s)\n",
                                YYDEBUGSTR, yydepth, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == YYEOF) goto yyaccept;
        goto yyloop;
    }
    if (((yyn = yygindex[yym]) != 0) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == (YYINT) yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
    {
        fprintf(stderr, "%s[%d]: after reduction, ", YYDEBUGSTR, yydepth);
#ifdef YYSTYPE_TOSTRING
#if YYBTYACC
        if (!yytrial)
#endif /* YYBTYACC */
            fprintf(stderr, "result is <%s>, ", YYSTYPE_TOSTRING(yystos[yystate], yyval));
#endif
        fprintf(stderr, "shifting from state %d to state %d\n", *yystack.s_mark, yystate);
    }
#endif
    if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM) goto yyoverflow;
    *++yystack.s_mark = (YYINT) yystate;
    *++yystack.l_mark = yyval;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
    *++yystack.p_mark = yyloc;
#endif
    goto yyloop;
#if YYBTYACC

    /* Reduction declares that this path is valid. Set yypath and do a full parse */
yyvalid:
    if (yypath) YYABORT;
    while (yyps->save)
    {
        YYParseState *save = yyps->save;
        yyps->save = save->save;
        save->save = yypath;
        yypath = save;
    }
#if YYDEBUG
    if (yydebug)
        fprintf(stderr, "%s[%d]: state %d, CONFLICT trial successful, backtracking to state %d, %d tokens\n",
                        YYDEBUGSTR, yydepth, yystate, yypath->state, (int)(yylvp - yylvals - yypath->lexeme));
#endif
    if (yyerrctx)
    {
        yyFreeState(yyerrctx);
        yyerrctx = NULL;
    }
    yylvp          = yylvals + yypath->lexeme;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
    yylpp          = yylpsns + yypath->lexeme;
#endif
    yylexp         = yylexemes + yypath->lexeme;
    yychar         = YYEMPTY;
    yystack.s_mark = yystack.s_base + (yypath->yystack.s_mark - yypath->yystack.s_base);
    memcpy (yystack.s_base, yypath->yystack.s_base, (size_t) (yystack.s_mark - yystack.s_base + 1) * sizeof(YYINT));
    yystack.l_mark = yystack.l_base + (yypath->yystack.l_mark - yypath->yystack.l_base);
    memcpy (yystack.l_base, yypath->yystack.l_base, (size_t) (yystack.l_mark - yystack.l_base + 1) * sizeof(YYSTYPE));
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
    yystack.p_mark = yystack.p_base + (yypath->yystack.p_mark - yypath->yystack.p_base);
    memcpy (yystack.p_base, yypath->yystack.p_base, (size_t) (yystack.p_mark - yystack.p_base + 1) * sizeof(YYLTYPE));
#endif
    yystate        = yypath->state;
    goto yyloop;
#endif /* YYBTYACC */

yyoverflow:
    YYERROR_CALL("yacc stack overflow");
#if YYBTYACC
    goto yyabort_nomem;
yyenomem:
    YYERROR_CALL("memory exhausted");
yyabort_nomem:
#endif /* YYBTYACC */
    yyresult = 2;
    goto yyreturn;

yyabort:
    yyresult = 1;
    goto yyreturn;

yyaccept:
#if YYBTYACC
    if (yyps->save) goto yyvalid;
#endif /* YYBTYACC */
    yyresult = 0;

yyreturn:
#if defined(YYDESTRUCT_CALL)
    if (yychar != YYEOF && yychar != YYEMPTY)
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
        YYDESTRUCT_CALL("cleanup: discarding token", yychar, &yylval, &yylloc);
#else
        YYDESTRUCT_CALL("cleanup: discarding token", yychar, &yylval);
#endif /* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */

    {
        YYSTYPE *pv;
#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
        YYLTYPE *pp;

        for (pv = yystack.l_base, pp = yystack.p_base; pv <= yystack.l_mark; ++pv, ++pp)
             YYDESTRUCT_CALL("cleanup: discarding state",
                             yystos[*(yystack.s_base + (pv - yystack.l_base))], pv, pp);
#else
        for (pv = yystack.l_base; pv <= yystack.l_mark; ++pv)
             YYDESTRUCT_CALL("cleanup: discarding state",
                             yystos[*(yystack.s_base + (pv - yystack.l_base))], pv);
#endif /* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */
    }
#endif /* defined(YYDESTRUCT_CALL) */

#if YYBTYACC
    if (yyerrctx)
    {
        yyFreeState(yyerrctx);
        yyerrctx = NULL;
    }
    while (yyps)
    {
        YYParseState *save = yyps;
        yyps = save->save;
        save->save = NULL;
        yyFreeState(save);
    }
    while (yypath)
    {
        YYParseState *save = yypath;
        yypath = save->save;
        save->save = NULL;
        yyFreeState(save);
    }
#endif /* YYBTYACC */
    yyfreestack(&yystack);
    return (yyresult);
}
